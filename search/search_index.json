{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"imgx \u00b6 Package imgx provides comprehensive image processing functions (resize, rotate, crop, brightness/contrast adjustments, effects) and AI-powered object detection using Google Gemini, AWS Rekognition, and OpenAI Vision APIs. All the image processing functions provided by the package accept any image type that implements image.Image interface as an input, and return a new image of *image.NRGBA type (32bit RGBA colors, non-premultiplied alpha). Table of Contents \u00b6 Installation As a Library As a CLI Tool Documentation CLI Documentation - Complete CLI guide Detection API - AI-powered object detection Version Management - How versions are managed Release Process - How to create releases Library Usage Examples Quick Start Image Resizing Image Rotation Image Flipping Gaussian Blur Sharpening Color Adjustments More Library Usage Examples Watermark Example Image Transformations Effects and Filters Advanced Example: Image Collage Features Performance FAQ Acknowledgments License Installation \u00b6 As a Library \u00b6 go get -u github.com/razzkumar/imgx As a CLI Tool \u00b6 # Install via go install (Recommended) go install github.com/razzkumar/imgx/cmd/imgx@latest # Or build from source go build -o imgx ./cmd/imgx Quick CLI Examples: # Resize an image imgx resize photo.jpg -w 800 -o resized.jpg # Create a thumbnail imgx thumbnail photo.jpg -s 150 -o thumb.jpg # Adjust colors imgx adjust photo.jpg --brightness 10 --contrast 20 -o adjusted.jpg # Apply blur effect imgx blur photo.jpg --sigma 2 .5 -o blurred.jpg # Detect objects using AI (local Ollama by default) imgx detect photo.jpg # Extract image metadata (requires exiftool for extended data) imgx metadata photo.jpg For complete CLI documentation with all commands, options, and examples, see CLI Documentation . Documentation \u00b6 Library API: https://pkg.go.dev/github.com/razzkumar/imgx CLI Tool: CLI.md Object Detection: DETECTION.md - AI vision with Ollama, Google Gemini, AWS Rekognition, OpenAI Library Usage Examples \u00b6 A few usage examples can be found below. See the documentation for the full list of supported functions. Quick Start - Using as a Library \u00b6 package main import ( \"log\" \"github.com/razzkumar/imgx\" ) func main () { // Load an image file img , err := imgx . Load ( \"input.jpg\" ) if err != nil { log . Fatalf ( \"failed to load image: %v\" , err ) } // Resize to width 800px, maintaining aspect ratio img = img . Resize ( 800 , 0 , imgx . Lanczos ) // Save the result (with automatic metadata tracking) err = img . Save ( \"output.jpg\" ) if err != nil { log . Fatalf ( \"failed to save image: %v\" , err ) } } Loading Options \u00b6 You can customize image loading by passing an Options struct: // Load with auto-orientation img , err := imgx . Load ( \"photo.jpg\" , imgx . Options { AutoOrient : true , // Apply EXIF orientation }) // Load with custom author img , err := imgx . Load ( \"photo.jpg\" , imgx . Options { Author : \"Your Name\" , // Override default author in metadata }) // Load with multiple options img , err := imgx . Load ( \"photo.jpg\" , imgx . Options { AutoOrient : true , Author : \"John Doe\" , DisableMetadata : false , // Enable/disable metadata tracking }) // Or just use defaults (no options needed) img , err := imgx . Load ( \"photo.jpg\" ) Available Options: - AutoOrient (bool) - Automatically correct image orientation from EXIF data - Author (string) - Set custom artist/creator name for metadata (empty = use default) - DisableMetadata (bool) - Disable automatic metadata tracking for this image Image resizing \u00b6 // Load an image img , _ := imgx . Load ( \"input.jpg\" ) // Resize to size = 128x128px using the Lanczos filter. img128 := img . Resize ( 128 , 128 , imgx . Lanczos ) // Resize to width = 800px preserving the aspect ratio. img800 := img . Resize ( 800 , 0 , imgx . Lanczos ) // Scale down to fit the 800x600px bounding box. imgFit := img . Fit ( 800 , 600 , imgx . Lanczos ) // Resize and crop to fill the 100x100px area. imgFill := img . Fill ( 100 , 100 , imgx . Center , imgx . Lanczos ) Example Output: Original Image (1280\u00d7853): After Resize(src, 200, 0, imgx.Lanczos) - Resized to width 200px, height auto: After Fill(src, 300, 300, imgx.Center, imgx.Lanczos) - Square thumbnail 300\u00d7300: Imaging supports image resizing using various resampling filters. The most notable ones: - Lanczos - A high-quality resampling filter for photographic images yielding sharp results. - CatmullRom - A sharp cubic filter that is faster than Lanczos filter while providing similar results. - MitchellNetravali - A cubic filter that produces smoother results with less ringing artifacts than CatmullRom. - Linear - Bilinear resampling filter, produces smooth output. Faster than cubic filters. - Box - Simple and fast averaging filter appropriate for downscaling. When upscaling it's similar to NearestNeighbor. - NearestNeighbor - Fastest resampling filter, no antialiasing. The full list of supported filters: NearestNeighbor, Box, Linear, Hermite, MitchellNetravali, CatmullRom, BSpline, Gaussian, Lanczos, Hann, Hamming, Blackman, Bartlett, Welch, Cosine. Custom filters can be created using ResampleFilter struct. Resampling filters comparison The same image can be resized using different resampling filters. From faster (lower quality) to slower (higher quality): NearestNeighbor , Linear , CatmullRom , Lanczos . Image Rotation \u00b6 // Load an image img , _ := imgx . Load ( \"input.jpg\" ) // Rotate 90 degrees clockwise ** Original Image : ** ![ Original flower ]( images / flower . jpg ) ** After `Blur(src, 2.0)` - Gaussian blur with sigma = 2.0 : ** ![ Blurred flower ]( images / flower_blur_2 . jpg ) ### Sharpening `` ` go // Load an image img , _ := imgx . Load ( \"input.jpg\" ) // Light sharpening lightSharp := img . Sharpen ( 0.5 ) // Medium sharpening mediumSharp := img . Sharpen ( 1.0 ) // Heavy sharpening heavySharp := img . Sharpen ( 2.0 ) Sharpen uses unsharp mask technique internally. Sigma parameter controls the strength of the sharpening effect. Example Output: Original Image: After Sharpen(src, 1.5) - Sharpened with sigma=1.5: Color Adjustments \u00b6 Gamma Correction \u00b6 // Load an image img , _ := imgx . Load ( \"input.jpg\" ) // Darken image (gamma < 1.0) darker := img . AdjustGamma ( 0.5 ) // Lighten image (gamma > 1.0) lighter := img . AdjustGamma ( 1.5 ) Contrast Adjustment \u00b6 // Load an image img , _ := imgx . Load ( \"input.jpg\" ) // Decrease contrast lowContrast := img . AdjustContrast ( - 20 ) // Increase contrast highContrast := img . AdjustContrast ( 20 ) Range: -100 (min contrast) to 100 (max contrast) Example Output: Original Image: After AdjustContrast(src, 30) - Increased contrast: Brightness Adjustment \u00b6 // Load an image img , _ := imgx . Load ( \"input.jpg\" ) // Decrease brightness darker := img . AdjustBrightness ( - 20 ) // Increase brightness brighter := img . AdjustBrightness ( 20 ) Range: -100 (darkest) to 100 (brightest) Example Output: Original Image: After AdjustBrightness(src, 30) - Increased brightness: Saturation Adjustment \u00b6 // Load an image img , _ := imgx . Load ( \"input.jpg\" ) // Desaturate (move towards grayscale) desaturated := img . AdjustSaturation ( - 50 ) // Increase saturation (more vivid colors) saturated := img . AdjustSaturation ( 50 ) // Complete desaturation grayscale := img . AdjustSaturation ( - 100 ) Range: -100 (grayscale) to 500 (highly saturated) Example Output: Original Image: After AdjustSaturation(src, 50) - Increased saturation: Hue Adjustment \u00b6 // Load an image img , _ := imgx . Load ( \"input.jpg\" ) // Shift hue by 20 degrees shifted := img . AdjustHue ( 20 ) // Shift hue by 180 degrees (complementary colors) inverted := img . AdjustHue ( 180 ) Range: -180 to 180 degrees Grayscale Conversion \u00b6 // Load an image img , _ := imgx . Load ( \"input.jpg\" ) // Convert image to grayscale gray := img . Grayscale () Example Output: Original Image: After Grayscale(src) - Converted to grayscale: Example: Complete color adjustment pipeline with method chaining // Load and process image with method chaining img , _ := imgx . Load ( \"input.jpg\" ) // Adjust multiple properties by chaining methods result := img . AdjustBrightness ( 10 ). AdjustContrast ( 20 ). AdjustSaturation ( 30 ) result . Save ( \"output_adjusted.jpg\" ) More Library Usage Examples \u00b6 Example 1: Create Thumbnail Gallery \u00b6 package main import ( \"log\" \"github.com/razzkumar/imgx\" ) func main () { // Load source image img , err := imgx . Load ( \"photo.jpg\" ) if err != nil { log . Fatal ( err ) } // Create different thumbnail sizes thumb100 := img . Thumbnail ( 100 , 100 , imgx . Lanczos ) thumb200 := img . Thumbnail ( 200 , 200 , imgx . Lanczos ) thumb400 := img . Thumbnail ( 400 , 400 , imgx . Lanczos ) // Save thumbnails thumb100 . Save ( \"thumb_100.jpg\" ) thumb200 . Save ( \"thumb_200.jpg\" ) thumb400 . Save ( \"thumb_400.jpg\" ) } Example 2: Batch Image Processing \u00b6 package main import ( \"log\" \"os\" \"path/filepath\" \"strings\" \"github.com/razzkumar/imgx\" ) func main () { // Process all JPG files in a directory files , _ := filepath . Glob ( \"input/*.jpg\" ) for _ , file := range files { // Load image img , err := imgx . Load ( file ) if err != nil { log . Printf ( \"Failed to load %s: %v\" , file , err ) continue } // Process with method chaining: resize, enhance contrast, and sharpen processed := img . Resize ( 1920 , 0 , imgx . Lanczos ). AdjustContrast ( 10 ). Sharpen ( 0.5 ) // Save with new name basename := filepath . Base ( file ) outname := \"output/\" + strings . TrimSuffix ( basename , \".jpg\" ) + \"_processed.jpg\" if err := processed . Save ( outname ); err != nil { log . Printf ( \"Failed to save %s: %v\" , outname , err ) } } } Example 3: Add Watermark \u00b6 package main import ( \"image\" \"log\" \"github.com/razzkumar/imgx\" ) func main () { // Load main image img , err := imgx . Load ( \"photo.jpg\" ) if err != nil { log . Fatal ( err ) } // Load watermark watermark , err := imgx . Load ( \"watermark.png\" ) if err != nil { log . Fatal ( err ) } // Resize watermark to 20% of image width bounds := img . Bounds () wmWidth := bounds . Dx () / 5 watermark = watermark . Resize ( wmWidth , 0 , imgx . Lanczos ) // Position watermark in bottom-right corner wmBounds := watermark . Bounds () position := image . Pt ( bounds . Dx () - wmBounds . Dx () - 20 , bounds . Dy () - wmBounds . Dy () - 20 , ) // Overlay watermark with transparency and save result := img . Overlay ( watermark , position , 0.6 ) result . Save ( \"watermarked.jpg\" ) } Example Output: Original Image: After adding watermark with Overlay() - Watermark in bottom-right corner with 60% opacity: Example 4: Image Transformations \u00b6 package main import ( \"log\" \"github.com/razzkumar/imgx\" ) func main () { img , err := imgx . Load ( \"photo.jpg\" ) if err != nil { log . Fatal ( err ) } // Rotate 90 degrees img . Rotate90 (). Save ( \"rotated_90.jpg\" ) // Rotate 45 degrees with white background img . Rotate ( 45 , imgx . White ). Save ( \"rotated_45.jpg\" ) // Flip horizontal img . FlipH (). Save ( \"flipped_h.jpg\" ) // Flip vertical img . FlipV (). Save ( \"flipped_v.jpg\" ) // Transpose (flip + rotate) img . Transpose (). Save ( \"transposed.jpg\" ) } Example 5: Image Effects and Filters \u00b6 package main import ( \"log\" \"github.com/razzkumar/imgx\" ) func main () { img , err := imgx . Load ( \"photo.jpg\" ) if err != nil { log . Fatal ( err ) } // Convert to grayscale img . Grayscale (). Save ( \"grayscale.jpg\" ) // Invert colors img . Invert (). Save ( \"inverted.jpg\" ) // Apply custom convolution (edge detection) img . Convolve3x3 ( [ 9 ] float64 { - 1 , - 1 , - 1 , - 1 , 8 , - 1 , - 1 , - 1 , - 1 , }, nil , ). Save ( \"edges.jpg\" ) // Emboss effect img . Convolve3x3 ( [ 9 ] float64 { - 1 , - 1 , 0 , - 1 , 1 , 1 , 0 , 1 , 1 , }, nil , ). Save ( \"embossed.jpg\" ) } Example 6: Working with Different Image Formats \u00b6 package main import ( \"log\" \"github.com/razzkumar/imgx\" ) func main () { // Load with auto-orientation from EXIF img , err := imgx . Load ( \"photo.jpg\" , imgx . Options { AutoOrient : true }) if err != nil { log . Fatal ( err ) } // Process processed := img . Resize ( 800 , 0 , imgx . Lanczos ) // Save as different formats (format auto-detected from extension) processed . Save ( \"output.jpg\" ) // JPEG processed . Save ( \"output.png\" ) // PNG processed . Save ( \"output.gif\" ) // GIF processed . Save ( \"output.tiff\" ) // TIFF processed . Save ( \"output.bmp\" ) // BMP } Example 7: Extract Image Metadata \u00b6 package main import ( \"fmt\" \"log\" \"github.com/razzkumar/imgx\" ) func main () { // Extract metadata (uses exiftool if available, falls back to basic metadata) metadata , err := imgx . Metadata ( \"photo.jpg\" ) if err != nil { log . Fatal ( err ) } // Display basic information (always available) fmt . Printf ( \"File: %s\\n\" , metadata . FilePath ) fmt . Printf ( \"Format: %s\\n\" , metadata . Format ) fmt . Printf ( \"Dimensions: %dx%d\\n\" , metadata . Width , metadata . Height ) fmt . Printf ( \"Megapixels: %.2f MP\\n\" , metadata . Megapixels ) // Display extended metadata if available (requires exiftool) if metadata . HasExtended { fmt . Println ( \"\\nExtended Metadata:\" ) if metadata . CameraMake != \"\" { fmt . Printf ( \"Camera: %s %s\\n\" , metadata . CameraMake , metadata . CameraModel ) } if metadata . DateTimeOriginal != \"\" { fmt . Printf ( \"Date Taken: %s\\n\" , metadata . DateTimeOriginal ) } if metadata . ISO != \"\" { fmt . Printf ( \"ISO: %s\\n\" , metadata . ISO ) } if metadata . GPSLatitude != \"\" { fmt . Printf ( \"GPS: %s, %s\\n\" , metadata . GPSLatitude , metadata . GPSLongitude ) } } else { fmt . Println ( \"\\nNote: Install exiftool for comprehensive metadata\" ) } // Extract basic metadata only (skip exiftool check) basicMeta , err := imgx . Metadata ( \"photo.jpg\" , imgx . WithBasicOnly ()) if err != nil { log . Fatal ( err ) } fmt . Printf ( \"\\nFile Size: %d bytes\\n\" , basicMeta . FileSize ) } Example 8: AI Object Detection \u00b6 package main import ( \"context\" \"fmt\" \"log\" \"github.com/razzkumar/imgx\" \"github.com/razzkumar/imgx/detection\" ) func main () { // Load image img , err := imgx . Load ( \"photo.jpg\" ) if err != nil { log . Fatal ( err ) } // Detect objects using the local Ollama model ctx := context . Background () result , err := img . Detect ( ctx , \"ollama\" ) if err != nil { log . Fatal ( err ) } // Display detected labels fmt . Println ( \"Detected objects:\" ) for _ , label := range result . Labels { fmt . Printf ( \"- %s (%.1f%% confidence)\\n\" , label . Name , label . Confidence * 100 ) } // Use AWS Rekognition for image properties opts := & detection . DetectOptions { Features : [] detection . Feature { detection . FeatureProperties }, } result , err = img . Detect ( ctx , \"aws\" , opts ) if err != nil { log . Fatal ( err ) } // Display image properties fmt . Printf ( \"\\nBrightness: %s\\n\" , result . Properties [ \"brightness\" ]) fmt . Printf ( \"Dominant colors: %s\\n\" , result . Properties [ \"dominant_colors\" ]) } For complete detection API documentation including all providers, features, and examples, see Detection Documentation . Automatic Processing Metadata Tracking \u00b6 imgx automatically tracks all processing operations applied to images and can embed this information as XMP metadata when saving. This feature provides full transparency about how images were processed. How It Works \u00b6 When you use the instance-based API ( imgx.Load() , method chaining), imgx automatically: 1. Records every operation (resize, rotate, adjust, etc.) 2. Tracks parameters for each operation 3. Timestamps each operation 4. Embeds this information as XMP metadata when saving (if exiftool is available) Basic Usage \u00b6 // Load an image - metadata tracking starts automatically img , _ := imgx . Load ( \"photo.jpg\" ) // Apply operations - each operation is recorded result := img . Resize ( 800 , 0 , imgx . Lanczos ). AdjustBrightness ( 10 ). AdjustContrast ( 20 ). Sharpen ( 1.0 ) // Save - metadata is automatically embedded in the output file result . Save ( \"output.jpg\" ) // The output.jpg file now contains XMP metadata with: // - Software: imgx v1.0.0 // - Processing history: resize, adjust brightness, adjust contrast, sharpen // - Parameters for each operation // - Timestamps for each operation Disabling Metadata \u00b6 There are three ways to disable metadata tracking: 1. Per-Image (at load time): // Disable metadata for a specific image img , _ := imgx . Load ( \"photo.jpg\" , imgx . Options { DisableMetadata : true }) img . Resize ( 800 , 0 , imgx . Lanczos ). Save ( \"output.jpg\" ) // No metadata written 2. Per-Save Operation: // Process with metadata tracking, but don't write it img , _ := imgx . Load ( \"photo.jpg\" ) result := img . Resize ( 800 , 0 , imgx . Lanczos ) result . Save ( \"output.jpg\" , imgx . WithoutMetadata ()) // Skip metadata on save 3. Globally (environment variable): # Disable metadata for all operations export IMGX_ADD_METADATA = false # Or in code: imgx.SetAddMetadata ( false ) Working with Standard Library \u00b6 The instance-based API is fully compatible with Go's standard image.Image interface: // Load from standard library image var stdImg image . Image = loadFromSomewhere () img := imgx . FromImage ( stdImg ) // Process with metadata tracking result := img . Resize ( 800 , 0 , imgx . Lanczos ) // Convert back to standard library type if needed nrgba := result . ToNRGBA () Method Chaining \u00b6 All processing methods return new *imgx.Image instances, allowing for clean method chaining: img , _ := imgx . Load ( \"photo.jpg\" ) // Chain multiple operations result := img . Resize ( 1920 , 0 , imgx . Lanczos ). CropCenter ( 1200 , 800 ). AdjustBrightness ( 10 ). AdjustContrast ( 15 ). AdjustSaturation ( 20 ). Sharpen ( 1.0 ) result . Save ( \"processed.jpg\" ) Migration from Functional API \u00b6 If you're migrating from the older functional API ( imgx.Open , imgx.Resize , etc.), both APIs are still available: Old (Functional API): img , _ := imgx . Open ( \"input.jpg\" ) img = imgx . Resize ( img , 800 , 0 , imgx . Lanczos ) img = imgx . AdjustContrast ( img , 20 ) imgx . Save ( img , \"output.jpg\" ) New (Instance-Based API with metadata): img , _ := imgx . Load ( \"input.jpg\" ) img = img . Resize ( 800 , 0 , imgx . Lanczos ). AdjustContrast ( 20 ) img . Save ( \"output.jpg\" ) The functional API remains available for backward compatibility but does not include automatic metadata tracking. FAQ \u00b6 Incorrect image orientation after processing (e.g. an image appears rotated after resizing) \u00b6 Most probably, the given image contains the EXIF orientation tag. The standard image/* packages do not support loading and saving this kind of information. To fix the issue, try opening images with the AutoOrientation decode option. If this option is set to true , the image orientation is changed after decoding, according to the orientation tag (if present). Here's the example: img , err := imgx . Load ( \"test.jpg\" , imgx . Options { AutoOrient : true }) What's the difference between imaging and gift packages? \u00b6 imaging is designed to be a lightweight and simple image manipulation package. It provides basic image processing functions and a few helper functions such as Open and Save . It consistently returns *image.NRGBA image type (8 bits per channel, RGBA). Advanced Example: Image Collage \u00b6 This example demonstrates creating a 2x2 collage with different effects applied to each quadrant: package main import ( \"image\" \"image/color\" \"log\" \"github.com/razzkumar/imgx\" ) func main () { // Load a test image. img , err := imgx . Load ( \"testdata/flower.jpg\" ) if err != nil { log . Fatalf ( \"failed to load image: %v\" , err ) } // Crop and resize using method chaining src := img . CropAnchor ( 300 , 300 , imgx . Center ). Resize ( 200 , 0 , imgx . Lanczos ) // Create a blurred version of the image. img1 := src . Blur ( 5 ) // Create a grayscale version with higher contrast and sharpness. img2 := src . Grayscale (). AdjustContrast ( 20 ). Sharpen ( 2 ) // Create an inverted version of the image. img3 := src . Invert () // Create an embossed version using a convolution filter. img4 := src . Convolve3x3 ( [ 9 ] float64 { - 1 , - 1 , 0 , - 1 , 1 , 1 , 0 , 1 , 1 , }, nil , ) // Create a new 400x400px image and paste the four produced images into it. dst := imgx . NewImage ( 400 , 400 , color . NRGBA { 0 , 0 , 0 , 0 }) dst = dst . Paste ( img1 , image . Pt ( 0 , 0 )) // Top-left: Blurred dst = dst . Paste ( img2 , image . Pt ( 0 , 200 )) // Bottom-left: Grayscale + Enhanced dst = dst . Paste ( img3 , image . Pt ( 200 , 0 )) // Top-right: Inverted dst = dst . Paste ( img4 , image . Pt ( 200 , 200 )) // Bottom-right: Embossed // Save the resulting image as JPEG. err = dst . Save ( \"testdata/out_example.jpg\" ) if err != nil { log . Fatalf ( \"failed to save image: %v\" , err ) } log . Println ( \"Collage created successfully: testdata/out_example.jpg\" ) } Output: A 2x2 grid showing the same image with four different effects applied. Features \u00b6 imgx provides a comprehensive set of image processing capabilities: Resizing & Transformations: - Multiple resampling filters (Lanczos, CatmullRom, Linear, Box, NearestNeighbor, etc.) - Resize, Fit, Fill, Thumbnail operations - Rotate (90\u00b0, 180\u00b0, 270\u00b0, arbitrary angles) - Flip horizontal/vertical, Transpose, Transverse - Crop with anchor points Color Adjustments: - Brightness, Contrast, Gamma correction - Saturation, Hue adjustments - Grayscale conversion - Color inversion Effects & Filters: - Gaussian blur - Unsharp mask sharpening - Custom 3x3 and 5x5 convolution kernels - Edge detection, emboss, and custom effects Image Composition: - Paste images together - Overlay with alpha blending - Watermarking support - Create collages and thumbnails I/O & Format Support: - Formats: JPEG, PNG, GIF, TIFF, BMP - EXIF auto-orientation for JPEG files - Encode/Decode with custom options - Format auto-detection from file extensions - Metadata extraction (EXIF, IPTC, XMP with exiftool) - Automatic processing metadata tracking and XMP embedding AI Object Detection: - Support for Google Gemini, AWS Rekognition, and OpenAI Vision - Label/object detection with confidence scores - Text extraction (OCR) - Face detection with attributes - Image quality analysis (brightness, sharpness, contrast) - Dominant color extraction - Natural language descriptions - See Detection Documentation for details API Design: - Instance-based API with method chaining for clean, readable code - Automatic operation tracking and metadata embedding - Functional API still available for backward compatibility - Interoperable with Go's standard image.Image interface Performance: - Parallel processing across CPU cores - Optimized scanners for common image formats - Separable filter approach for resize and blur - Memory-efficient streaming operations Performance \u00b6 imgx is designed for high performance with parallel processing and optimized algorithms. Running Benchmarks \u00b6 # Run all benchmarks go test -bench = . # Run specific benchmark with memory stats go test -bench = BenchmarkResize -benchmem # Run benchmarks multiple times for accuracy go test -bench = . -benchtime = 10s -count = 3 Example Benchmark Results \u00b6 BenchmarkResize-8 100 12.3 ms/op 8.2 MB/s 4.5 MB/op BenchmarkBlur-8 50 24.5 ms/op 4.1 MB/s 6.2 MB/op BenchmarkRotate90-8 200 5.8 ms/op 17.2 MB/s 2.1 MB/op BenchmarkGrayscale-8 300 4.2 ms/op 23.8 MB/s 1.8 MB/op The library automatically utilizes all available CPU cores for operations on large images. You can control parallelism using: imgx . SetMaxProcs ( 4 ) // Limit to 4 CPU cores Acknowledgments \u00b6 imgx is a brand new image processing library designed from the ground up with modern Go practices. We drew inspiration from: imaging by Grigory Dryapak - for foundational image processing algorithms and API design patterns go-exiftool - for metadata handling approaches and exiftool integration concepts What Makes imgx Different? \u00b6 imgx is a complete reimagination with a modern architecture: Instance-based API : Fluent method-chaining design for intuitive, readable code Automatic metadata tracking : Built-in operation history with XMP embedding Modern Go 1.21+ features : Range over integers, built-in min/max WaitGroup.Go() for goroutines Latest benchmarking patterns Comprehensive CLI : Full-featured command-line tool with metadata support Clean architecture : Modular design with clear separation of concerns Developer-friendly : Extensive documentation, examples, and type safety Thank you to the Go community and these projects for the inspiration! License \u00b6 This project is licensed under the MIT License. See the LICENSE file for details. Copyright (c) 2025 razzkumar","title":"Home"},{"location":"#imgx","text":"Package imgx provides comprehensive image processing functions (resize, rotate, crop, brightness/contrast adjustments, effects) and AI-powered object detection using Google Gemini, AWS Rekognition, and OpenAI Vision APIs. All the image processing functions provided by the package accept any image type that implements image.Image interface as an input, and return a new image of *image.NRGBA type (32bit RGBA colors, non-premultiplied alpha).","title":"imgx"},{"location":"#table-of-contents","text":"Installation As a Library As a CLI Tool Documentation CLI Documentation - Complete CLI guide Detection API - AI-powered object detection Version Management - How versions are managed Release Process - How to create releases Library Usage Examples Quick Start Image Resizing Image Rotation Image Flipping Gaussian Blur Sharpening Color Adjustments More Library Usage Examples Watermark Example Image Transformations Effects and Filters Advanced Example: Image Collage Features Performance FAQ Acknowledgments License","title":"Table of Contents"},{"location":"#installation","text":"","title":"Installation"},{"location":"#as-a-library","text":"go get -u github.com/razzkumar/imgx","title":"As a Library"},{"location":"#as-a-cli-tool","text":"# Install via go install (Recommended) go install github.com/razzkumar/imgx/cmd/imgx@latest # Or build from source go build -o imgx ./cmd/imgx Quick CLI Examples: # Resize an image imgx resize photo.jpg -w 800 -o resized.jpg # Create a thumbnail imgx thumbnail photo.jpg -s 150 -o thumb.jpg # Adjust colors imgx adjust photo.jpg --brightness 10 --contrast 20 -o adjusted.jpg # Apply blur effect imgx blur photo.jpg --sigma 2 .5 -o blurred.jpg # Detect objects using AI (local Ollama by default) imgx detect photo.jpg # Extract image metadata (requires exiftool for extended data) imgx metadata photo.jpg For complete CLI documentation with all commands, options, and examples, see CLI Documentation .","title":"As a CLI Tool"},{"location":"#documentation","text":"Library API: https://pkg.go.dev/github.com/razzkumar/imgx CLI Tool: CLI.md Object Detection: DETECTION.md - AI vision with Ollama, Google Gemini, AWS Rekognition, OpenAI","title":"Documentation"},{"location":"#library-usage-examples","text":"A few usage examples can be found below. See the documentation for the full list of supported functions.","title":"Library Usage Examples"},{"location":"#quick-start-using-as-a-library","text":"package main import ( \"log\" \"github.com/razzkumar/imgx\" ) func main () { // Load an image file img , err := imgx . Load ( \"input.jpg\" ) if err != nil { log . Fatalf ( \"failed to load image: %v\" , err ) } // Resize to width 800px, maintaining aspect ratio img = img . Resize ( 800 , 0 , imgx . Lanczos ) // Save the result (with automatic metadata tracking) err = img . Save ( \"output.jpg\" ) if err != nil { log . Fatalf ( \"failed to save image: %v\" , err ) } }","title":"Quick Start - Using as a Library"},{"location":"#loading-options","text":"You can customize image loading by passing an Options struct: // Load with auto-orientation img , err := imgx . Load ( \"photo.jpg\" , imgx . Options { AutoOrient : true , // Apply EXIF orientation }) // Load with custom author img , err := imgx . Load ( \"photo.jpg\" , imgx . Options { Author : \"Your Name\" , // Override default author in metadata }) // Load with multiple options img , err := imgx . Load ( \"photo.jpg\" , imgx . Options { AutoOrient : true , Author : \"John Doe\" , DisableMetadata : false , // Enable/disable metadata tracking }) // Or just use defaults (no options needed) img , err := imgx . Load ( \"photo.jpg\" ) Available Options: - AutoOrient (bool) - Automatically correct image orientation from EXIF data - Author (string) - Set custom artist/creator name for metadata (empty = use default) - DisableMetadata (bool) - Disable automatic metadata tracking for this image","title":"Loading Options"},{"location":"#image-resizing","text":"// Load an image img , _ := imgx . Load ( \"input.jpg\" ) // Resize to size = 128x128px using the Lanczos filter. img128 := img . Resize ( 128 , 128 , imgx . Lanczos ) // Resize to width = 800px preserving the aspect ratio. img800 := img . Resize ( 800 , 0 , imgx . Lanczos ) // Scale down to fit the 800x600px bounding box. imgFit := img . Fit ( 800 , 600 , imgx . Lanczos ) // Resize and crop to fill the 100x100px area. imgFill := img . Fill ( 100 , 100 , imgx . Center , imgx . Lanczos ) Example Output: Original Image (1280\u00d7853): After Resize(src, 200, 0, imgx.Lanczos) - Resized to width 200px, height auto: After Fill(src, 300, 300, imgx.Center, imgx.Lanczos) - Square thumbnail 300\u00d7300: Imaging supports image resizing using various resampling filters. The most notable ones: - Lanczos - A high-quality resampling filter for photographic images yielding sharp results. - CatmullRom - A sharp cubic filter that is faster than Lanczos filter while providing similar results. - MitchellNetravali - A cubic filter that produces smoother results with less ringing artifacts than CatmullRom. - Linear - Bilinear resampling filter, produces smooth output. Faster than cubic filters. - Box - Simple and fast averaging filter appropriate for downscaling. When upscaling it's similar to NearestNeighbor. - NearestNeighbor - Fastest resampling filter, no antialiasing. The full list of supported filters: NearestNeighbor, Box, Linear, Hermite, MitchellNetravali, CatmullRom, BSpline, Gaussian, Lanczos, Hann, Hamming, Blackman, Bartlett, Welch, Cosine. Custom filters can be created using ResampleFilter struct. Resampling filters comparison The same image can be resized using different resampling filters. From faster (lower quality) to slower (higher quality): NearestNeighbor , Linear , CatmullRom , Lanczos .","title":"Image resizing"},{"location":"#image-rotation","text":"// Load an image img , _ := imgx . Load ( \"input.jpg\" ) // Rotate 90 degrees clockwise ** Original Image : ** ![ Original flower ]( images / flower . jpg ) ** After `Blur(src, 2.0)` - Gaussian blur with sigma = 2.0 : ** ![ Blurred flower ]( images / flower_blur_2 . jpg ) ### Sharpening `` ` go // Load an image img , _ := imgx . Load ( \"input.jpg\" ) // Light sharpening lightSharp := img . Sharpen ( 0.5 ) // Medium sharpening mediumSharp := img . Sharpen ( 1.0 ) // Heavy sharpening heavySharp := img . Sharpen ( 2.0 ) Sharpen uses unsharp mask technique internally. Sigma parameter controls the strength of the sharpening effect. Example Output: Original Image: After Sharpen(src, 1.5) - Sharpened with sigma=1.5:","title":"Image Rotation"},{"location":"#color-adjustments","text":"","title":"Color Adjustments"},{"location":"#gamma-correction","text":"// Load an image img , _ := imgx . Load ( \"input.jpg\" ) // Darken image (gamma < 1.0) darker := img . AdjustGamma ( 0.5 ) // Lighten image (gamma > 1.0) lighter := img . AdjustGamma ( 1.5 )","title":"Gamma Correction"},{"location":"#contrast-adjustment","text":"// Load an image img , _ := imgx . Load ( \"input.jpg\" ) // Decrease contrast lowContrast := img . AdjustContrast ( - 20 ) // Increase contrast highContrast := img . AdjustContrast ( 20 ) Range: -100 (min contrast) to 100 (max contrast) Example Output: Original Image: After AdjustContrast(src, 30) - Increased contrast:","title":"Contrast Adjustment"},{"location":"#brightness-adjustment","text":"// Load an image img , _ := imgx . Load ( \"input.jpg\" ) // Decrease brightness darker := img . AdjustBrightness ( - 20 ) // Increase brightness brighter := img . AdjustBrightness ( 20 ) Range: -100 (darkest) to 100 (brightest) Example Output: Original Image: After AdjustBrightness(src, 30) - Increased brightness:","title":"Brightness Adjustment"},{"location":"#saturation-adjustment","text":"// Load an image img , _ := imgx . Load ( \"input.jpg\" ) // Desaturate (move towards grayscale) desaturated := img . AdjustSaturation ( - 50 ) // Increase saturation (more vivid colors) saturated := img . AdjustSaturation ( 50 ) // Complete desaturation grayscale := img . AdjustSaturation ( - 100 ) Range: -100 (grayscale) to 500 (highly saturated) Example Output: Original Image: After AdjustSaturation(src, 50) - Increased saturation:","title":"Saturation Adjustment"},{"location":"#hue-adjustment","text":"// Load an image img , _ := imgx . Load ( \"input.jpg\" ) // Shift hue by 20 degrees shifted := img . AdjustHue ( 20 ) // Shift hue by 180 degrees (complementary colors) inverted := img . AdjustHue ( 180 ) Range: -180 to 180 degrees","title":"Hue Adjustment"},{"location":"#grayscale-conversion","text":"// Load an image img , _ := imgx . Load ( \"input.jpg\" ) // Convert image to grayscale gray := img . Grayscale () Example Output: Original Image: After Grayscale(src) - Converted to grayscale: Example: Complete color adjustment pipeline with method chaining // Load and process image with method chaining img , _ := imgx . Load ( \"input.jpg\" ) // Adjust multiple properties by chaining methods result := img . AdjustBrightness ( 10 ). AdjustContrast ( 20 ). AdjustSaturation ( 30 ) result . Save ( \"output_adjusted.jpg\" )","title":"Grayscale Conversion"},{"location":"#more-library-usage-examples","text":"","title":"More Library Usage Examples"},{"location":"#example-1-create-thumbnail-gallery","text":"package main import ( \"log\" \"github.com/razzkumar/imgx\" ) func main () { // Load source image img , err := imgx . Load ( \"photo.jpg\" ) if err != nil { log . Fatal ( err ) } // Create different thumbnail sizes thumb100 := img . Thumbnail ( 100 , 100 , imgx . Lanczos ) thumb200 := img . Thumbnail ( 200 , 200 , imgx . Lanczos ) thumb400 := img . Thumbnail ( 400 , 400 , imgx . Lanczos ) // Save thumbnails thumb100 . Save ( \"thumb_100.jpg\" ) thumb200 . Save ( \"thumb_200.jpg\" ) thumb400 . Save ( \"thumb_400.jpg\" ) }","title":"Example 1: Create Thumbnail Gallery"},{"location":"#example-2-batch-image-processing","text":"package main import ( \"log\" \"os\" \"path/filepath\" \"strings\" \"github.com/razzkumar/imgx\" ) func main () { // Process all JPG files in a directory files , _ := filepath . Glob ( \"input/*.jpg\" ) for _ , file := range files { // Load image img , err := imgx . Load ( file ) if err != nil { log . Printf ( \"Failed to load %s: %v\" , file , err ) continue } // Process with method chaining: resize, enhance contrast, and sharpen processed := img . Resize ( 1920 , 0 , imgx . Lanczos ). AdjustContrast ( 10 ). Sharpen ( 0.5 ) // Save with new name basename := filepath . Base ( file ) outname := \"output/\" + strings . TrimSuffix ( basename , \".jpg\" ) + \"_processed.jpg\" if err := processed . Save ( outname ); err != nil { log . Printf ( \"Failed to save %s: %v\" , outname , err ) } } }","title":"Example 2: Batch Image Processing"},{"location":"#example-3-add-watermark","text":"package main import ( \"image\" \"log\" \"github.com/razzkumar/imgx\" ) func main () { // Load main image img , err := imgx . Load ( \"photo.jpg\" ) if err != nil { log . Fatal ( err ) } // Load watermark watermark , err := imgx . Load ( \"watermark.png\" ) if err != nil { log . Fatal ( err ) } // Resize watermark to 20% of image width bounds := img . Bounds () wmWidth := bounds . Dx () / 5 watermark = watermark . Resize ( wmWidth , 0 , imgx . Lanczos ) // Position watermark in bottom-right corner wmBounds := watermark . Bounds () position := image . Pt ( bounds . Dx () - wmBounds . Dx () - 20 , bounds . Dy () - wmBounds . Dy () - 20 , ) // Overlay watermark with transparency and save result := img . Overlay ( watermark , position , 0.6 ) result . Save ( \"watermarked.jpg\" ) } Example Output: Original Image: After adding watermark with Overlay() - Watermark in bottom-right corner with 60% opacity:","title":"Example 3: Add Watermark"},{"location":"#example-4-image-transformations","text":"package main import ( \"log\" \"github.com/razzkumar/imgx\" ) func main () { img , err := imgx . Load ( \"photo.jpg\" ) if err != nil { log . Fatal ( err ) } // Rotate 90 degrees img . Rotate90 (). Save ( \"rotated_90.jpg\" ) // Rotate 45 degrees with white background img . Rotate ( 45 , imgx . White ). Save ( \"rotated_45.jpg\" ) // Flip horizontal img . FlipH (). Save ( \"flipped_h.jpg\" ) // Flip vertical img . FlipV (). Save ( \"flipped_v.jpg\" ) // Transpose (flip + rotate) img . Transpose (). Save ( \"transposed.jpg\" ) }","title":"Example 4: Image Transformations"},{"location":"#example-5-image-effects-and-filters","text":"package main import ( \"log\" \"github.com/razzkumar/imgx\" ) func main () { img , err := imgx . Load ( \"photo.jpg\" ) if err != nil { log . Fatal ( err ) } // Convert to grayscale img . Grayscale (). Save ( \"grayscale.jpg\" ) // Invert colors img . Invert (). Save ( \"inverted.jpg\" ) // Apply custom convolution (edge detection) img . Convolve3x3 ( [ 9 ] float64 { - 1 , - 1 , - 1 , - 1 , 8 , - 1 , - 1 , - 1 , - 1 , }, nil , ). Save ( \"edges.jpg\" ) // Emboss effect img . Convolve3x3 ( [ 9 ] float64 { - 1 , - 1 , 0 , - 1 , 1 , 1 , 0 , 1 , 1 , }, nil , ). Save ( \"embossed.jpg\" ) }","title":"Example 5: Image Effects and Filters"},{"location":"#example-6-working-with-different-image-formats","text":"package main import ( \"log\" \"github.com/razzkumar/imgx\" ) func main () { // Load with auto-orientation from EXIF img , err := imgx . Load ( \"photo.jpg\" , imgx . Options { AutoOrient : true }) if err != nil { log . Fatal ( err ) } // Process processed := img . Resize ( 800 , 0 , imgx . Lanczos ) // Save as different formats (format auto-detected from extension) processed . Save ( \"output.jpg\" ) // JPEG processed . Save ( \"output.png\" ) // PNG processed . Save ( \"output.gif\" ) // GIF processed . Save ( \"output.tiff\" ) // TIFF processed . Save ( \"output.bmp\" ) // BMP }","title":"Example 6: Working with Different Image Formats"},{"location":"#example-7-extract-image-metadata","text":"package main import ( \"fmt\" \"log\" \"github.com/razzkumar/imgx\" ) func main () { // Extract metadata (uses exiftool if available, falls back to basic metadata) metadata , err := imgx . Metadata ( \"photo.jpg\" ) if err != nil { log . Fatal ( err ) } // Display basic information (always available) fmt . Printf ( \"File: %s\\n\" , metadata . FilePath ) fmt . Printf ( \"Format: %s\\n\" , metadata . Format ) fmt . Printf ( \"Dimensions: %dx%d\\n\" , metadata . Width , metadata . Height ) fmt . Printf ( \"Megapixels: %.2f MP\\n\" , metadata . Megapixels ) // Display extended metadata if available (requires exiftool) if metadata . HasExtended { fmt . Println ( \"\\nExtended Metadata:\" ) if metadata . CameraMake != \"\" { fmt . Printf ( \"Camera: %s %s\\n\" , metadata . CameraMake , metadata . CameraModel ) } if metadata . DateTimeOriginal != \"\" { fmt . Printf ( \"Date Taken: %s\\n\" , metadata . DateTimeOriginal ) } if metadata . ISO != \"\" { fmt . Printf ( \"ISO: %s\\n\" , metadata . ISO ) } if metadata . GPSLatitude != \"\" { fmt . Printf ( \"GPS: %s, %s\\n\" , metadata . GPSLatitude , metadata . GPSLongitude ) } } else { fmt . Println ( \"\\nNote: Install exiftool for comprehensive metadata\" ) } // Extract basic metadata only (skip exiftool check) basicMeta , err := imgx . Metadata ( \"photo.jpg\" , imgx . WithBasicOnly ()) if err != nil { log . Fatal ( err ) } fmt . Printf ( \"\\nFile Size: %d bytes\\n\" , basicMeta . FileSize ) }","title":"Example 7: Extract Image Metadata"},{"location":"#example-8-ai-object-detection","text":"package main import ( \"context\" \"fmt\" \"log\" \"github.com/razzkumar/imgx\" \"github.com/razzkumar/imgx/detection\" ) func main () { // Load image img , err := imgx . Load ( \"photo.jpg\" ) if err != nil { log . Fatal ( err ) } // Detect objects using the local Ollama model ctx := context . Background () result , err := img . Detect ( ctx , \"ollama\" ) if err != nil { log . Fatal ( err ) } // Display detected labels fmt . Println ( \"Detected objects:\" ) for _ , label := range result . Labels { fmt . Printf ( \"- %s (%.1f%% confidence)\\n\" , label . Name , label . Confidence * 100 ) } // Use AWS Rekognition for image properties opts := & detection . DetectOptions { Features : [] detection . Feature { detection . FeatureProperties }, } result , err = img . Detect ( ctx , \"aws\" , opts ) if err != nil { log . Fatal ( err ) } // Display image properties fmt . Printf ( \"\\nBrightness: %s\\n\" , result . Properties [ \"brightness\" ]) fmt . Printf ( \"Dominant colors: %s\\n\" , result . Properties [ \"dominant_colors\" ]) } For complete detection API documentation including all providers, features, and examples, see Detection Documentation .","title":"Example 8: AI Object Detection"},{"location":"#automatic-processing-metadata-tracking","text":"imgx automatically tracks all processing operations applied to images and can embed this information as XMP metadata when saving. This feature provides full transparency about how images were processed.","title":"Automatic Processing Metadata Tracking"},{"location":"#how-it-works","text":"When you use the instance-based API ( imgx.Load() , method chaining), imgx automatically: 1. Records every operation (resize, rotate, adjust, etc.) 2. Tracks parameters for each operation 3. Timestamps each operation 4. Embeds this information as XMP metadata when saving (if exiftool is available)","title":"How It Works"},{"location":"#basic-usage","text":"// Load an image - metadata tracking starts automatically img , _ := imgx . Load ( \"photo.jpg\" ) // Apply operations - each operation is recorded result := img . Resize ( 800 , 0 , imgx . Lanczos ). AdjustBrightness ( 10 ). AdjustContrast ( 20 ). Sharpen ( 1.0 ) // Save - metadata is automatically embedded in the output file result . Save ( \"output.jpg\" ) // The output.jpg file now contains XMP metadata with: // - Software: imgx v1.0.0 // - Processing history: resize, adjust brightness, adjust contrast, sharpen // - Parameters for each operation // - Timestamps for each operation","title":"Basic Usage"},{"location":"#disabling-metadata","text":"There are three ways to disable metadata tracking: 1. Per-Image (at load time): // Disable metadata for a specific image img , _ := imgx . Load ( \"photo.jpg\" , imgx . Options { DisableMetadata : true }) img . Resize ( 800 , 0 , imgx . Lanczos ). Save ( \"output.jpg\" ) // No metadata written 2. Per-Save Operation: // Process with metadata tracking, but don't write it img , _ := imgx . Load ( \"photo.jpg\" ) result := img . Resize ( 800 , 0 , imgx . Lanczos ) result . Save ( \"output.jpg\" , imgx . WithoutMetadata ()) // Skip metadata on save 3. Globally (environment variable): # Disable metadata for all operations export IMGX_ADD_METADATA = false # Or in code: imgx.SetAddMetadata ( false )","title":"Disabling Metadata"},{"location":"#working-with-standard-library","text":"The instance-based API is fully compatible with Go's standard image.Image interface: // Load from standard library image var stdImg image . Image = loadFromSomewhere () img := imgx . FromImage ( stdImg ) // Process with metadata tracking result := img . Resize ( 800 , 0 , imgx . Lanczos ) // Convert back to standard library type if needed nrgba := result . ToNRGBA ()","title":"Working with Standard Library"},{"location":"#method-chaining","text":"All processing methods return new *imgx.Image instances, allowing for clean method chaining: img , _ := imgx . Load ( \"photo.jpg\" ) // Chain multiple operations result := img . Resize ( 1920 , 0 , imgx . Lanczos ). CropCenter ( 1200 , 800 ). AdjustBrightness ( 10 ). AdjustContrast ( 15 ). AdjustSaturation ( 20 ). Sharpen ( 1.0 ) result . Save ( \"processed.jpg\" )","title":"Method Chaining"},{"location":"#migration-from-functional-api","text":"If you're migrating from the older functional API ( imgx.Open , imgx.Resize , etc.), both APIs are still available: Old (Functional API): img , _ := imgx . Open ( \"input.jpg\" ) img = imgx . Resize ( img , 800 , 0 , imgx . Lanczos ) img = imgx . AdjustContrast ( img , 20 ) imgx . Save ( img , \"output.jpg\" ) New (Instance-Based API with metadata): img , _ := imgx . Load ( \"input.jpg\" ) img = img . Resize ( 800 , 0 , imgx . Lanczos ). AdjustContrast ( 20 ) img . Save ( \"output.jpg\" ) The functional API remains available for backward compatibility but does not include automatic metadata tracking.","title":"Migration from Functional API"},{"location":"#faq","text":"","title":"FAQ"},{"location":"#incorrect-image-orientation-after-processing-eg-an-image-appears-rotated-after-resizing","text":"Most probably, the given image contains the EXIF orientation tag. The standard image/* packages do not support loading and saving this kind of information. To fix the issue, try opening images with the AutoOrientation decode option. If this option is set to true , the image orientation is changed after decoding, according to the orientation tag (if present). Here's the example: img , err := imgx . Load ( \"test.jpg\" , imgx . Options { AutoOrient : true })","title":"Incorrect image orientation after processing (e.g. an image appears rotated after resizing)"},{"location":"#whats-the-difference-between-imaging-and-gift-packages","text":"imaging is designed to be a lightweight and simple image manipulation package. It provides basic image processing functions and a few helper functions such as Open and Save . It consistently returns *image.NRGBA image type (8 bits per channel, RGBA).","title":"What's the difference between imaging and gift packages?"},{"location":"#advanced-example-image-collage","text":"This example demonstrates creating a 2x2 collage with different effects applied to each quadrant: package main import ( \"image\" \"image/color\" \"log\" \"github.com/razzkumar/imgx\" ) func main () { // Load a test image. img , err := imgx . Load ( \"testdata/flower.jpg\" ) if err != nil { log . Fatalf ( \"failed to load image: %v\" , err ) } // Crop and resize using method chaining src := img . CropAnchor ( 300 , 300 , imgx . Center ). Resize ( 200 , 0 , imgx . Lanczos ) // Create a blurred version of the image. img1 := src . Blur ( 5 ) // Create a grayscale version with higher contrast and sharpness. img2 := src . Grayscale (). AdjustContrast ( 20 ). Sharpen ( 2 ) // Create an inverted version of the image. img3 := src . Invert () // Create an embossed version using a convolution filter. img4 := src . Convolve3x3 ( [ 9 ] float64 { - 1 , - 1 , 0 , - 1 , 1 , 1 , 0 , 1 , 1 , }, nil , ) // Create a new 400x400px image and paste the four produced images into it. dst := imgx . NewImage ( 400 , 400 , color . NRGBA { 0 , 0 , 0 , 0 }) dst = dst . Paste ( img1 , image . Pt ( 0 , 0 )) // Top-left: Blurred dst = dst . Paste ( img2 , image . Pt ( 0 , 200 )) // Bottom-left: Grayscale + Enhanced dst = dst . Paste ( img3 , image . Pt ( 200 , 0 )) // Top-right: Inverted dst = dst . Paste ( img4 , image . Pt ( 200 , 200 )) // Bottom-right: Embossed // Save the resulting image as JPEG. err = dst . Save ( \"testdata/out_example.jpg\" ) if err != nil { log . Fatalf ( \"failed to save image: %v\" , err ) } log . Println ( \"Collage created successfully: testdata/out_example.jpg\" ) } Output: A 2x2 grid showing the same image with four different effects applied.","title":"Advanced Example: Image Collage"},{"location":"#features","text":"imgx provides a comprehensive set of image processing capabilities: Resizing & Transformations: - Multiple resampling filters (Lanczos, CatmullRom, Linear, Box, NearestNeighbor, etc.) - Resize, Fit, Fill, Thumbnail operations - Rotate (90\u00b0, 180\u00b0, 270\u00b0, arbitrary angles) - Flip horizontal/vertical, Transpose, Transverse - Crop with anchor points Color Adjustments: - Brightness, Contrast, Gamma correction - Saturation, Hue adjustments - Grayscale conversion - Color inversion Effects & Filters: - Gaussian blur - Unsharp mask sharpening - Custom 3x3 and 5x5 convolution kernels - Edge detection, emboss, and custom effects Image Composition: - Paste images together - Overlay with alpha blending - Watermarking support - Create collages and thumbnails I/O & Format Support: - Formats: JPEG, PNG, GIF, TIFF, BMP - EXIF auto-orientation for JPEG files - Encode/Decode with custom options - Format auto-detection from file extensions - Metadata extraction (EXIF, IPTC, XMP with exiftool) - Automatic processing metadata tracking and XMP embedding AI Object Detection: - Support for Google Gemini, AWS Rekognition, and OpenAI Vision - Label/object detection with confidence scores - Text extraction (OCR) - Face detection with attributes - Image quality analysis (brightness, sharpness, contrast) - Dominant color extraction - Natural language descriptions - See Detection Documentation for details API Design: - Instance-based API with method chaining for clean, readable code - Automatic operation tracking and metadata embedding - Functional API still available for backward compatibility - Interoperable with Go's standard image.Image interface Performance: - Parallel processing across CPU cores - Optimized scanners for common image formats - Separable filter approach for resize and blur - Memory-efficient streaming operations","title":"Features"},{"location":"#performance","text":"imgx is designed for high performance with parallel processing and optimized algorithms.","title":"Performance"},{"location":"#running-benchmarks","text":"# Run all benchmarks go test -bench = . # Run specific benchmark with memory stats go test -bench = BenchmarkResize -benchmem # Run benchmarks multiple times for accuracy go test -bench = . -benchtime = 10s -count = 3","title":"Running Benchmarks"},{"location":"#example-benchmark-results","text":"BenchmarkResize-8 100 12.3 ms/op 8.2 MB/s 4.5 MB/op BenchmarkBlur-8 50 24.5 ms/op 4.1 MB/s 6.2 MB/op BenchmarkRotate90-8 200 5.8 ms/op 17.2 MB/s 2.1 MB/op BenchmarkGrayscale-8 300 4.2 ms/op 23.8 MB/s 1.8 MB/op The library automatically utilizes all available CPU cores for operations on large images. You can control parallelism using: imgx . SetMaxProcs ( 4 ) // Limit to 4 CPU cores","title":"Example Benchmark Results"},{"location":"#acknowledgments","text":"imgx is a brand new image processing library designed from the ground up with modern Go practices. We drew inspiration from: imaging by Grigory Dryapak - for foundational image processing algorithms and API design patterns go-exiftool - for metadata handling approaches and exiftool integration concepts","title":"Acknowledgments"},{"location":"#what-makes-imgx-different","text":"imgx is a complete reimagination with a modern architecture: Instance-based API : Fluent method-chaining design for intuitive, readable code Automatic metadata tracking : Built-in operation history with XMP embedding Modern Go 1.21+ features : Range over integers, built-in min/max WaitGroup.Go() for goroutines Latest benchmarking patterns Comprehensive CLI : Full-featured command-line tool with metadata support Clean architecture : Modular design with clear separation of concerns Developer-friendly : Extensive documentation, examples, and type safety Thank you to the Go community and these projects for the inspiration!","title":"What Makes imgx Different?"},{"location":"#license","text":"This project is licensed under the MIT License. See the LICENSE file for details. Copyright (c) 2025 razzkumar","title":"License"},{"location":"CLI/","text":"imgx CLI Documentation \u00b6 A powerful command-line tool for image processing operations including resizing, transformations, color adjustments, effects, and watermarking. Table of Contents \u00b6 Installation Shell Completion Quick Start Global Options Commands Resize Operations Transform Operations Color Adjustments Effects Watermarking Image Information Object Detection Common Use Cases Tips & Tricks Installation \u00b6 # Install via go install (Recommended) go install github.com/razzkumar/imgx/cmd/imgx@latest # Or build from source go build -o imgx ./cmd/imgx Shell Completion \u00b6 imgx supports shell completion for Bash, Zsh, Fish, and PowerShell. This enables tab completion for commands, flags, and options. Bash \u00b6 Temporary (current session only): source < ( imgx completion bash ) Permanent: # Save to completion directory imgx completion bash > ~/.bash_completion.d/imgx source ~/.bash_completion.d/imgx # Or add to .bashrc echo 'source <(imgx completion bash)' >> ~/.bashrc Zsh \u00b6 Add to .zshrc : # Enable completions if not already enabled autoload -Uz compinit compinit # Load imgx completions source < ( imgx completion zsh ) # Or add this line to .zshrc echo 'source <(imgx completion zsh)' >> ~/.zshrc Alternative (using completion directory): # Save to zsh completion directory imgx completion zsh > \" ${ fpath [1] } /_imgx\" Fish \u00b6 # Save to fish completion directory imgx completion fish > ~/.config/fish/completions/imgx.fish PowerShell \u00b6 # Generate completion script imgx completion pwsh > imgx . ps1 # Load completions (add to your PowerShell profile) & path \\ to \\ imgx . ps1 To find your PowerShell profile location: echo $PROFILE Testing Completions \u00b6 After setting up completions, test them by typing: imgx <TAB> # Shows all available commands imgx resize <TAB> # Shows subcommands and help imgx --<TAB> # Shows global flags (--output, --quality, etc.) What Completions Support \u00b6 The shell completions currently support: \u2705 Command completion - Complete command names (resize, adjust, blur, etc.) \u2705 Subcommand completion - Navigate through command hierarchy \u2705 Global flag completion - Complete global flags at the root level (--output, --quality, --verbose) \u26a0\ufe0f Subcommand flags - Limited support for flags within subcommands (use imgx <command> --help to see available flags) \u26a0\ufe0f Important: Shell Completion Quirk \u00b6 When you type imgx <command> <TAB> , the completion will suggest help as an option. However: DON'T use: imgx thumbnail help \u274c (will fail with \"Required flag not set\" error) DO use instead: imgx help thumbnail \u2705 or imgx thumbnail --help \u2705 The completion system suggests help because it's technically a subcommand, but it doesn't work correctly with commands that have required flags. Always use one of the correct help syntaxes shown above. Note: To see all available flags for a specific command, use the help system: imgx adjust --help # Shows all adjust command flags imgx resize --help # Shows all resize command flags Quick Start \u00b6 # Resize an image imgx resize photo.jpg -w 800 -o resized.jpg # Create a thumbnail imgx thumbnail photo.jpg -s 150 -o thumb.jpg # Adjust colors imgx adjust photo.jpg --brightness 10 --contrast 20 -o adjusted.jpg # Get image info imgx info photo.jpg Global Options \u00b6 Global options can be used with any command: Flag Description Default -o, --output <path> Output file path Auto-generated -q, --quality <1-100> JPEG quality 95 --auto-orient Auto-orient based on EXIF data false --format <fmt> Force output format (jpg, png, gif, tiff, bmp) Detected from filename -v, --verbose Verbose output false --help, -h Show help --version Show version Examples: # Save as JPEG with quality 90 imgx resize photo.png -w 800 -o output.jpg --quality 90 # Force PNG format with verbose output imgx grayscale photo.jpg --format png -v -o output.png # Auto-orient image based on EXIF before processing imgx resize photo.jpg -w 800 --auto-orient -o output.jpg Commands \u00b6 Resize Operations \u00b6 resize - Resize to specific dimensions \u00b6 Resize an image to the specified width and height. If one dimension is 0, the aspect ratio is preserved. imgx resize <input> [ options ] Options: - -w, --width <int> - Target width (0 to preserve aspect ratio) - -h, --height <int> - Target height (0 to preserve aspect ratio) - -f, --filter <name> - Resampling filter (default: lanczos) Available Filters: lanczos , catmullrom , mitchellnetravali , linear , box , nearest , hermite , bspline , gaussian , hann , hamming , blackman , bartlett , welch , cosine Examples: # Resize to 800x600 imgx resize photo.jpg -w 800 -h 600 -o output.jpg # Resize to width 800, preserve aspect ratio imgx resize photo.jpg -w 800 -o output.jpg # Resize with different filter imgx resize photo.jpg -w 800 -f catmullrom -o output.jpg fit - Scale to fit within bounds \u00b6 Scale the image to fit within the specified dimensions while preserving aspect ratio. imgx fit <input> -w <width> -h <height> [ options ] Options: - -w, --width <int> - Maximum width (required) - -h, --height <int> - Maximum height (required) - -f, --filter <name> - Resampling filter (default: lanczos) Example: # Fit image within 800x600 bounding box imgx fit photo.jpg -w 800 -h 600 -o output.jpg fill - Crop and resize to exact dimensions \u00b6 Resize and crop the image to fill the specified dimensions exactly. The image is scaled to cover the target size, then cropped to fit. imgx fill <input> -w <width> -h <height> [ options ] Options: - -w, --width <int> - Target width (required) - -h, --height <int> - Target height (required) - -a, --anchor <pos> - Anchor position (default: center) - -f, --filter <name> - Resampling filter (default: lanczos) Anchor Positions: center , topleft , top , topright , left , right , bottomleft , bottom , bottomright Examples: # Fill 800x600 with center crop imgx fill photo.jpg -w 800 -h 600 -o output.jpg # Fill with top-left anchor imgx fill photo.jpg -w 800 -h 600 --anchor topleft -o output.jpg thumbnail - Create square thumbnail \u00b6 Create a square thumbnail by cropping and resizing. imgx thumbnail <input> -s <size> [ options ] Options: - -s, --size <int> - Thumbnail size (width and height) (required) - -f, --filter <name> - Resampling filter (default: lanczos) Example: imgx thumbnail photo.jpg -s 150 -o thumb.jpg Transform Operations \u00b6 rotate - Rotate by angle \u00b6 Rotate an image by the specified angle in degrees. Positive angles rotate counter-clockwise, negative angles rotate clockwise. Rotations of 90, 180, and 270 degrees are lossless. imgx rotate <input> -a <angle> [ options ] Options: - -a, --angle <float> - Rotation angle in degrees (required) - --bg <color> - Background color for empty areas (default: 00000000 = transparent) Color Format: RGB hex ( ffffff ) or RGBA hex ( ff0000ff ) Examples: # Rotate 90 degrees counter-clockwise imgx rotate photo.jpg -a 90 -o output.jpg # Rotate 45 degrees with white background imgx rotate photo.jpg -a 45 --bg ffffff -o output.jpg # Rotate 30 degrees clockwise (negative angle) imgx rotate photo.jpg -a -30 -o output.jpg Quick Rotation Commands \u00b6 For common rotations, use these shortcuts: # 90 degrees counter-clockwise imgx rotate90 photo.jpg -o output.jpg # 180 degrees imgx rotate180 photo.jpg -o output.jpg # 270 degrees counter-clockwise (90 clockwise) imgx rotate270 photo.jpg -o output.jpg flip - Flip horizontally or vertically \u00b6 Flip an image horizontally (left-right), vertically (top-bottom), or both. imgx flip <input> [ options ] Options: - --horizontal, -H - Flip horizontally (left-right) - --vertical, -V - Flip vertically (top-bottom) Examples: # Flip horizontally imgx flip photo.jpg --horizontal -o output.jpg # Flip vertically imgx flip photo.jpg --vertical -o output.jpg # Flip both (same as rotate 180) imgx flip photo.jpg --horizontal --vertical -o output.jpg crop - Crop to region \u00b6 Crop an image to a specific region using either anchor positioning or exact coordinates. imgx crop <input> -w <width> -h <height> [ options ] Options: - -w, --width <int> - Crop width (required) - -h, --height <int> - Crop height (required) - -a, --anchor <pos> - Anchor position (default: center) - -x <int> - X coordinate (left edge, exclusive with --anchor) - -y <int> - Y coordinate (top edge, exclusive with --anchor) Examples: # Crop 500x400 from center imgx crop photo.jpg -w 500 -h 400 --anchor center -o output.jpg # Crop from specific coordinates imgx crop photo.jpg -x 100 -y 100 -w 500 -h 400 -o output.jpg # Crop from top-left imgx crop photo.jpg -w 500 -h 400 --anchor topleft -o output.jpg transpose / transverse - Advanced transforms \u00b6 Special transformation operations: # Transpose: flip horizontally + rotate 90\u00b0 CCW imgx transpose photo.jpg -o output.jpg # Transverse: flip vertically + rotate 90\u00b0 CCW imgx transverse photo.jpg -o output.jpg Color Adjustments \u00b6 adjust - Adjust colors \u00b6 Adjust various color properties of an image. Multiple adjustments can be applied at once and are processed in order: brightness \u2192 contrast \u2192 gamma \u2192 saturation \u2192 hue. imgx adjust <input> [ options ] Options: - --brightness <float> - Brightness adjustment (-100 to 100, 0 = no change) - --contrast <float> - Contrast adjustment (-100 to 100, 0 = no change) - --gamma <float> - Gamma correction (positive number, 1.0 = no change) - --saturation <float> - Saturation adjustment (-100 to 100, 0 = no change) - --hue <float> - Hue shift in degrees (-180 to 180, 0 = no change) Examples: # Increase brightness and contrast imgx adjust photo.jpg --brightness 10 --contrast 20 -o output.jpg # Adjust saturation and hue imgx adjust photo.jpg --saturation -30 --hue 60 -o output.jpg # Apply gamma correction imgx adjust photo.jpg --gamma 1 .5 -o output.jpg # Multiple adjustments at once imgx adjust photo.jpg --brightness 10 --contrast 15 --saturation 20 --gamma 1 .2 -o output.jpg grayscale - Convert to grayscale \u00b6 Convert an image to grayscale using ITU-R BT.601 luminance weights. imgx grayscale <input> [ options ] Example: imgx grayscale photo.jpg -o output.jpg invert - Invert colors \u00b6 Invert (negate) all colors in the image to create a negative effect. imgx invert <input> [ options ] Example: imgx invert photo.jpg -o output.jpg Effects \u00b6 blur - Gaussian blur \u00b6 Apply a Gaussian blur effect to the image. Higher sigma values produce stronger blur. imgx blur <input> -s <sigma> [ options ] Options: - -s, --sigma <float> - Blur strength (required, positive number, typical: 0.5-10) Examples: # Subtle blur imgx blur photo.jpg --sigma 1 .5 -o output.jpg # Strong blur imgx blur photo.jpg -s 5 .0 -o output.jpg sharpen - Sharpen image \u00b6 Sharpen the image using unsharp masking. Higher sigma values produce stronger sharpening. imgx sharpen <input> -s <sigma> [ options ] Options: - -s, --sigma <float> - Sharpening strength (required, positive number, typical: 0.5-5) Examples: # Moderate sharpening imgx sharpen photo.jpg --sigma 1 .5 -o output.jpg # Strong sharpening imgx sharpen photo.jpg -s 3 .0 -o output.jpg Watermarking \u00b6 watermark - Add text watermark \u00b6 Add a text watermark to an image with configurable position, opacity, color, and padding. imgx watermark <input> -t <text> [ options ] Options: - -t, --text <string> - Watermark text (required) - --opacity <float> - Opacity (0.0 to 1.0, default: 0.5) - -a, --anchor <pos> - Position (default: bottomright) - --color <color> - Text color in hex (default: ffffff = white) - --padding <int> - Padding from edges in pixels (default: 10) Color Format: RGB hex ( ffffff ) or RGBA hex ( ff0000ff ) Examples: # Simple copyright watermark imgx watermark photo.jpg --text \"Copyright 2025\" -o output.jpg # Draft watermark in center with red color imgx watermark photo.jpg --text \"DRAFT\" --opacity 0 .3 --anchor center --color ff0000 -o output.jpg # Top-left watermark with custom padding imgx watermark photo.jpg --text \"Sample\" --anchor topleft --padding 20 -o output.jpg # Semi-transparent watermark with RGBA color imgx watermark photo.jpg --text \"Watermark\" --color ff000080 -o output.jpg Image Information \u00b6 info - Display image information \u00b6 Display detailed information about an image file. imgx info <input> [ options ] Options: - -e, --extended - Show extended metadata (requires exiftool) Output includes: - File path - Image format (JPEG, PNG, GIF, TIFF, BMP) - Dimensions (width \u00d7 height) - File size - Color model With --extended flag (requires exiftool): - Camera information and settings - GPS location data - Date/time metadata - Copyright and authorship Examples: # Basic info imgx info photo.jpg # Extended metadata imgx info photo.jpg --extended Sample basic output: File: photo.jpg Format: JPEG Dimensions: 1920x1080 Size: 245.3 KB Color Model: *color.modelFunc Sample extended output: File: photo.jpg Format: JPEG Dimensions: 1920x1080 Size: 245.3 KB Color Model: *color.modelFunc Camera: Make: Canon Model: Canon EOS 5D Mark IV Date Taken: 2024:10:15 14:23:45 Settings: Focal Length: 50.0 mm Aperture: f/1.8 ISO: 400 metadata - Extract comprehensive metadata \u00b6 Extract and display comprehensive image metadata including EXIF, IPTC, and XMP data. imgx metadata <input> [ options ] Options: - -b, --basic - Show basic metadata only (skip exiftool) - -j, --json - Output metadata as JSON Features: When exiftool is installed , displays: - Camera Information: Make, model, lens - Camera Settings: ISO, aperture (f-number), shutter speed, focal length, flash - GPS Location: Latitude, longitude, altitude - Date/Time: Original capture date, modification date - Additional Info: Software, artist, copyright - File Details: Format, dimensions, aspect ratio, megapixels, file size, color model When exiftool is NOT installed , displays basic metadata: - File path, format, and size - Image dimensions and aspect ratio - Megapixels and color model - Warning message with installation instructions Examples: # Display all available metadata imgx metadata photo.jpg # Show basic metadata only (skip exiftool) imgx metadata photo.jpg --basic # Output as JSON for parsing imgx metadata photo.jpg --json > metadata.json Sample output (with exiftool): === Image Metadata === File Information: Path: photo.jpg Format: JPEG Size: 2.3 MB Image Properties: Dimensions: 4000x3000 Aspect Ratio: 1.33 Megapixels: 12.00 MP Color Model: *color.modelFunc Camera Information: Make: Canon Model: Canon EOS 5D Mark IV Lens: EF50mm f/1.8 STM Camera Settings: Focal Length: 50.0 mm Aperture: f/1.8 Shutter: 1/250 ISO: 400 Flash: No Flash Date/Time: Original: 2024:10:15 14:23:45 Modified: 2024:10:20 09:15:30 GPS Location: Latitude: 37.7749 N Longitude: 122.4194 W Altitude: 15.0 m Additional Information: Software: Adobe Photoshop CC 2024 Copyright: \u00a9 2024 John Doe Sample output (without exiftool): === Image Metadata === File Information: Path: photo.jpg Format: JPEG Size: 2.3 MB Image Properties: Dimensions: 4000x3000 Aspect Ratio: 1.33 Megapixels: 12.00 MP Color Model: *color.modelFunc --- exiftool not found. Install exiftool for comprehensive metadata. Installation: macOS: brew install exiftool Ubuntu: sudo apt-get install libimage-exiftool-perl Windows: https://exiftool.org JSON Output Example: imgx metadata photo.jpg --json { \"FilePath\" : \"photo.jpg\" , \"Format\" : \"JPEG\" , \"Width\" : 4000 , \"Height\" : 3000 , \"FileSize\" : 2415919 , \"Megapixels\" : 12.00 , \"AspectRatio\" : 1.33 , \"HasExtended\" : true , \"CameraMake\" : \"Canon\" , \"CameraModel\" : \"Canon EOS 5D Mark IV\" , \"ISO\" : \"400\" , \"FocalLength\" : \"50.0 mm\" , \"DateTimeOriginal\" : \"2024:10:15 14:23:45\" } Installing exiftool: # macOS brew install exiftool # Ubuntu/Debian sudo apt-get install libimage-exiftool-perl # Fedora/RHEL sudo dnf install perl-Image-ExifTool # Windows # Download from https://exiftool.org and add to PATH # Verify installation exiftool -ver Object Detection \u00b6 detect - AI-powered object detection \u00b6 Detect objects, text, faces, and image properties using local Ollama models or cloud AI vision APIs (Google Gemini, AWS Rekognition, OpenAI Vision). imgx detect <input> [ options ] Options: - -p, --provider string - Detection provider: ollama , gemini , google (alias), aws , openai (default: ollama ) - -f, --features string - Features to detect: labels,text,faces,web,description,properties (comma-separated, default: labels ) - -m, --max-results int - Maximum number of labels to return (default: 10) - -c, --confidence float - Minimum confidence threshold 0.0-1.0 (default: 0.5) - --prompt string - Custom prompt for Ollama/Gemini/OpenAI (overrides --features) - -j, --json - Output results as JSON (includes colors, quality, moderation when available) - --raw - Include raw API response in output Supported Providers: - ollama (local multimodal models) - Requires ollama serve plus local model (default gemma3 ) - gemini (Google Gemini API) - Requires GEMINI_API_KEY - aws (AWS Rekognition) - Requires AWS credentials - openai (OpenAI Vision) - Requires OPENAI_API_KEY Setup: # Ollama: run the local server and pull a model ollama serve & ollama pull gemma3 # Optional overrides export OLLAMA_HOST = \"http://127.0.0.1:11434\" export IMGX_OLLAMA_MODEL = \"llava\" # Gemini: Get API key from https://aistudio.google.com/ export GEMINI_API_KEY = \"your-api-key\" # AWS: Configure via AWS CLI or environment variables aws configure # OR export AWS_ACCESS_KEY_ID = \"your-key\" export AWS_SECRET_ACCESS_KEY = \"your-secret\" export AWS_REGION = \"us-east-1\" # OpenAI: Get API key from https://platform.openai.com/ export OPENAI_API_KEY = \"sk-...\" Available Features: - labels - Detect objects and labels - text - Extract text (OCR) - faces - Detect faces and attributes - description - Get natural language description (Ollama/Gemini/OpenAI) - web - Web entities and similar images (Gemini only) - landmarks - Detect famous landmarks (Gemini only) - properties - Image quality, colors, sharpness (Ollama/AWS) - safesearch - Content moderation Examples: # Basic detection with the local Ollama model (default) imgx detect photo.jpg # Use specific provider imgx detect photo.jpg --provider aws # Multiple features imgx detect document.jpg --features labels,text,faces # AWS image properties (colors, quality) imgx detect photo.jpg --provider aws --features properties # AWS labels + properties (charged for both) imgx detect photo.jpg --provider aws --features labels,properties # Custom prompt with Ollama or Gemini imgx detect dog.jpg --prompt \"What breed is this dog?\" # Higher confidence threshold imgx detect photo.jpg --confidence 0 .8 # JSON output imgx detect photo.jpg --json # Compare providers imgx detect photo.jpg --provider ollama imgx detect photo.jpg --provider gemini imgx detect photo.jpg --provider aws imgx detect photo.jpg --provider openai Sample Output (pretty format): === Object Detection Results (aws) === Labels: 1. Dog (99.0% confidence) 2. Pet (97.6% confidence) 3. Animal (96.3% confidence) Detected Text: 1. \"Backyard\" (88.0% confidence) Properties: brightness: 84.50 contrast: 76.20 foreground_color: Green Dominant Colors: - Green (#8FB94B, rgb(143,185,75), 41.3%) - Brown (#6B4E2E, rgb(107,78,46), 18.6%) Image Quality: Brightness: 84.50 Contrast: 76.20 Sharpness: 80.10 Foreground: Brightness: 81.20 Color: Green Moderation: - Violence (severity: VERY_UNLIKELY, confidence: 0.5%) Safe Search Summary: - Violence (VERY_UNLIKELY, 0.5%) Overall Confidence: 97.6% Processed at: 2024-11-01 16:30:45 JSON Output Example: { \"provider\" : \"gemini\" , \"labels\" : [ { \"name\" : \"Dog\" , \"confidence\" : 0.985 , \"categories\" : [ \"Animal\" , \"Pet\" ] }, { \"name\" : \"Golden Retriever\" , \"confidence\" : 0.942 , \"categories\" : [ \"Dog\" , \"Breed\" ] } ], \"confidence\" : 0.934 , \"processed_at\" : \"2024-11-01T16:30:45Z\" } AWS Image Properties Output: imgx detect photo.jpg --provider aws --features properties # Output: Provider: aws Processed: 2024 -11-01 16 :30:45 Image Properties: brightness: 75 .23 sharpness: 89 .15 contrast: 62 .45 dominant_colors: Black ( 45 .2% ) , White ( 23 .1% ) , Blue ( 15 .7% ) color_1_hex: #0C0F12 color_1_rgb: rgb ( 12 ,15,18 ) color_2_hex: #F5F5F5 color_2_rgb: rgb ( 245 ,245,245 ) foreground_color: Black background_color: White Text Extraction Example: imgx detect document.jpg --features text # Output: Provider: gemini Processed: 2024 -11-01 16 :30:45 Text Detected: - \"Invoice\" ( confidence: 99 .2% ) - \"Total: $152 .50\" ( confidence: 98 .7% ) - \"Date: 2024-10-15\" ( confidence: 97 .5% ) Face Detection Example: imgx detect group-photo.jpg --features faces # Output: Provider: aws Processed: 2024 -11-01 16 :30:45 Faces Detected: 3 Face 1 : confidence 99 .8%, age 25 -35, smiling Face 2 : confidence 99 .5%, age 30 -40, neutral Face 3 : confidence 98 .9%, age 20 -30, happy Pricing Notes: Gemini : Free tier available, then pay-as-you-go AWS Rekognition : --features labels \u2192 Standard DetectLabels pricing (~$0.001/image) --features properties \u2192 Image Properties pricing only --features labels,properties \u2192 Charged for BOTH APIs OpenAI Vision : Per-request pricing based on GPT-4o Troubleshooting: # Test Gemini credentials echo $GEMINI_API_KEY # Test AWS credentials aws sts get-caller-identity # Test OpenAI credentials echo $OPENAI_API_KEY See Also: - Detailed API documentation: docs/DETECTION.md - Example code: examples/detection/main.go Common Use Cases \u00b6 Web Optimization \u00b6 # Resize for web and optimize JPEG quality imgx resize photo.jpg -w 1200 --quality 85 -o web.jpg # Create responsive image set imgx resize photo.jpg -w 1920 -o photo-large.jpg imgx resize photo.jpg -w 1200 -o photo-medium.jpg imgx resize photo.jpg -w 800 -o photo-small.jpg Social Media \u00b6 # Instagram post (1080x1080) imgx fill photo.jpg -w 1080 -h 1080 -o instagram.jpg # Facebook cover (1200x630) imgx fill photo.jpg -w 1200 -h 630 -o facebook-cover.jpg # Twitter header (1500x500) imgx fill photo.jpg -w 1500 -h 500 -o twitter-header.jpg Photo Enhancement \u00b6 # Quick enhancement imgx adjust photo.jpg --brightness 5 --contrast 10 --saturation 15 -o enhanced.jpg # Fix dark photo imgx adjust photo.jpg --brightness 20 --gamma 1 .3 -o brightened.jpg # Boost colors imgx adjust photo.jpg --saturation 25 --contrast 10 -o vibrant.jpg Thumbnails \u00b6 # Square thumbnails imgx thumbnail photo.jpg -s 150 -o thumb-150.jpg imgx thumbnail photo.jpg -s 300 -o thumb-300.jpg # Preserve aspect ratio thumbnails imgx resize photo.jpg -w 300 -o thumb.jpg Watermarking \u00b6 # Copyright watermark imgx watermark photo.jpg --text \"\u00a9 2025 Your Name\" --opacity 0 .4 -o watermarked.jpg # Draft stamp imgx watermark document.jpg --text \"DRAFT\" --anchor center --opacity 0 .3 --color ff0000 -o draft.jpg # Bottom-left attribution imgx watermark photo.jpg --text \"Photo by You\" --anchor bottomleft --padding 15 -o attributed.jpg Creative Effects \u00b6 # Soft focus effect imgx blur photo.jpg --sigma 3 .0 -o soft-focus.jpg # High contrast black and white imgx grayscale photo.jpg -o bw.jpg imgx adjust bw.jpg --contrast 30 -o high-contrast-bw.jpg # Vintage look imgx adjust photo.jpg --saturation -20 --contrast -10 --gamma 1 .2 -o vintage.jpg # Inverted colors (negative) imgx invert photo.jpg -o negative.jpg Tips & Tricks \u00b6 Auto-generated Output Names \u00b6 If you don't specify an output file with -o , imgx automatically generates one by adding a suffix: imgx resize photo.jpg -w 800 # Creates: photo-resized.jpg imgx thumbnail photo.jpg -s 150 # Creates: photo-thumb.jpg imgx grayscale photo.jpg # Creates: photo-grayscale.jpg Format Conversion \u00b6 Convert between formats using the --format flag: # PNG to JPEG imgx resize photo.png -w 800 --format jpg --quality 90 -o output.jpg # JPEG to PNG imgx resize photo.jpg -w 800 --format png -o output.png Preserving Quality \u00b6 For JPEG output, use high quality settings to preserve detail: # High quality (larger file) imgx resize photo.jpg -w 1920 --quality 95 -o output.jpg # Balanced quality imgx resize photo.jpg -w 1920 --quality 85 -o output.jpg # Web optimized imgx resize photo.jpg -w 1920 --quality 75 -o output.jpg Chaining Operations \u00b6 While command chaining is planned for a future release, you can currently chain operations using shell pipes or by saving intermediate files: # Method 1: Multiple commands imgx resize photo.jpg -w 800 -o temp.jpg imgx adjust temp.jpg --brightness 10 --contrast 20 -o final.jpg rm temp.jpg # Method 2: Multiple adjustments in one command imgx adjust photo.jpg --brightness 10 --contrast 20 --saturation 15 -o adjusted.jpg Verbose Mode \u00b6 Use verbose mode ( -v ) to see what operations are being performed: imgx adjust photo.jpg --brightness 10 --contrast 20 -v -o output.jpg # Output: # Loaded: photo.jpg (1920x1080) # Applying brightness: 10.0 # Applying contrast: 20.0 # Saving: output.jpg (1920x1080) # Saved: output.jpg Resampling Filters \u00b6 Choose the right filter for your use case: Lanczos (default): Best quality for most photographic images CatmullRom : Fast, sharp results similar to Lanczos MitchellNetravali : Smoother results with less ringing Linear : Fast bilinear resampling, good for quick previews Box : Fast averaging, good for downscaling Nearest : Fastest, no antialiasing (pixelated for photos) # High quality photographic resize imgx resize photo.jpg -w 800 -f lanczos -o output.jpg # Fast resize for previews imgx resize photo.jpg -w 800 -f linear -o preview.jpg # Pixel art (no smoothing) imgx resize pixelart.png -w 800 -f nearest -o scaled-pixelart.png Getting Help \u00b6 imgx provides comprehensive help at every level. General Help \u00b6 # Show all commands imgx --help imgx -h # Version information imgx --version Command-Specific Help \u00b6 There are two ways to get help for a specific command: Method 1: help before the command name imgx help resize imgx help adjust imgx help watermark Method 2: --help flag after the command name (also shows global options) imgx resize --help imgx adjust --help imgx watermark --help Note: Don't use imgx <command> help (help after the command) - this syntax doesn't work correctly. Shell Completion Scripts \u00b6 imgx completion bash imgx completion zsh imgx completion fish imgx completion pwsh Exit Codes \u00b6 0 - Success 1 - Error (invalid arguments, file not found, processing error, etc.) Supported Formats \u00b6 Input formats: JPEG, PNG, GIF, TIFF, BMP Output formats: JPEG, PNG, GIF, TIFF, BMP Format is automatically detected from file extension or can be forced with --format flag.","title":"CLI Documentation"},{"location":"CLI/#imgx-cli-documentation","text":"A powerful command-line tool for image processing operations including resizing, transformations, color adjustments, effects, and watermarking.","title":"imgx CLI Documentation"},{"location":"CLI/#table-of-contents","text":"Installation Shell Completion Quick Start Global Options Commands Resize Operations Transform Operations Color Adjustments Effects Watermarking Image Information Object Detection Common Use Cases Tips & Tricks","title":"Table of Contents"},{"location":"CLI/#installation","text":"# Install via go install (Recommended) go install github.com/razzkumar/imgx/cmd/imgx@latest # Or build from source go build -o imgx ./cmd/imgx","title":"Installation"},{"location":"CLI/#shell-completion","text":"imgx supports shell completion for Bash, Zsh, Fish, and PowerShell. This enables tab completion for commands, flags, and options.","title":"Shell Completion"},{"location":"CLI/#bash","text":"Temporary (current session only): source < ( imgx completion bash ) Permanent: # Save to completion directory imgx completion bash > ~/.bash_completion.d/imgx source ~/.bash_completion.d/imgx # Or add to .bashrc echo 'source <(imgx completion bash)' >> ~/.bashrc","title":"Bash"},{"location":"CLI/#zsh","text":"Add to .zshrc : # Enable completions if not already enabled autoload -Uz compinit compinit # Load imgx completions source < ( imgx completion zsh ) # Or add this line to .zshrc echo 'source <(imgx completion zsh)' >> ~/.zshrc Alternative (using completion directory): # Save to zsh completion directory imgx completion zsh > \" ${ fpath [1] } /_imgx\"","title":"Zsh"},{"location":"CLI/#fish","text":"# Save to fish completion directory imgx completion fish > ~/.config/fish/completions/imgx.fish","title":"Fish"},{"location":"CLI/#powershell","text":"# Generate completion script imgx completion pwsh > imgx . ps1 # Load completions (add to your PowerShell profile) & path \\ to \\ imgx . ps1 To find your PowerShell profile location: echo $PROFILE","title":"PowerShell"},{"location":"CLI/#testing-completions","text":"After setting up completions, test them by typing: imgx <TAB> # Shows all available commands imgx resize <TAB> # Shows subcommands and help imgx --<TAB> # Shows global flags (--output, --quality, etc.)","title":"Testing Completions"},{"location":"CLI/#what-completions-support","text":"The shell completions currently support: \u2705 Command completion - Complete command names (resize, adjust, blur, etc.) \u2705 Subcommand completion - Navigate through command hierarchy \u2705 Global flag completion - Complete global flags at the root level (--output, --quality, --verbose) \u26a0\ufe0f Subcommand flags - Limited support for flags within subcommands (use imgx <command> --help to see available flags)","title":"What Completions Support"},{"location":"CLI/#important-shell-completion-quirk","text":"When you type imgx <command> <TAB> , the completion will suggest help as an option. However: DON'T use: imgx thumbnail help \u274c (will fail with \"Required flag not set\" error) DO use instead: imgx help thumbnail \u2705 or imgx thumbnail --help \u2705 The completion system suggests help because it's technically a subcommand, but it doesn't work correctly with commands that have required flags. Always use one of the correct help syntaxes shown above. Note: To see all available flags for a specific command, use the help system: imgx adjust --help # Shows all adjust command flags imgx resize --help # Shows all resize command flags","title":"\u26a0\ufe0f Important: Shell Completion Quirk"},{"location":"CLI/#quick-start","text":"# Resize an image imgx resize photo.jpg -w 800 -o resized.jpg # Create a thumbnail imgx thumbnail photo.jpg -s 150 -o thumb.jpg # Adjust colors imgx adjust photo.jpg --brightness 10 --contrast 20 -o adjusted.jpg # Get image info imgx info photo.jpg","title":"Quick Start"},{"location":"CLI/#global-options","text":"Global options can be used with any command: Flag Description Default -o, --output <path> Output file path Auto-generated -q, --quality <1-100> JPEG quality 95 --auto-orient Auto-orient based on EXIF data false --format <fmt> Force output format (jpg, png, gif, tiff, bmp) Detected from filename -v, --verbose Verbose output false --help, -h Show help --version Show version Examples: # Save as JPEG with quality 90 imgx resize photo.png -w 800 -o output.jpg --quality 90 # Force PNG format with verbose output imgx grayscale photo.jpg --format png -v -o output.png # Auto-orient image based on EXIF before processing imgx resize photo.jpg -w 800 --auto-orient -o output.jpg","title":"Global Options"},{"location":"CLI/#commands","text":"","title":"Commands"},{"location":"CLI/#resize-operations","text":"","title":"Resize Operations"},{"location":"CLI/#resize-resize-to-specific-dimensions","text":"Resize an image to the specified width and height. If one dimension is 0, the aspect ratio is preserved. imgx resize <input> [ options ] Options: - -w, --width <int> - Target width (0 to preserve aspect ratio) - -h, --height <int> - Target height (0 to preserve aspect ratio) - -f, --filter <name> - Resampling filter (default: lanczos) Available Filters: lanczos , catmullrom , mitchellnetravali , linear , box , nearest , hermite , bspline , gaussian , hann , hamming , blackman , bartlett , welch , cosine Examples: # Resize to 800x600 imgx resize photo.jpg -w 800 -h 600 -o output.jpg # Resize to width 800, preserve aspect ratio imgx resize photo.jpg -w 800 -o output.jpg # Resize with different filter imgx resize photo.jpg -w 800 -f catmullrom -o output.jpg","title":"resize - Resize to specific dimensions"},{"location":"CLI/#fit-scale-to-fit-within-bounds","text":"Scale the image to fit within the specified dimensions while preserving aspect ratio. imgx fit <input> -w <width> -h <height> [ options ] Options: - -w, --width <int> - Maximum width (required) - -h, --height <int> - Maximum height (required) - -f, --filter <name> - Resampling filter (default: lanczos) Example: # Fit image within 800x600 bounding box imgx fit photo.jpg -w 800 -h 600 -o output.jpg","title":"fit - Scale to fit within bounds"},{"location":"CLI/#fill-crop-and-resize-to-exact-dimensions","text":"Resize and crop the image to fill the specified dimensions exactly. The image is scaled to cover the target size, then cropped to fit. imgx fill <input> -w <width> -h <height> [ options ] Options: - -w, --width <int> - Target width (required) - -h, --height <int> - Target height (required) - -a, --anchor <pos> - Anchor position (default: center) - -f, --filter <name> - Resampling filter (default: lanczos) Anchor Positions: center , topleft , top , topright , left , right , bottomleft , bottom , bottomright Examples: # Fill 800x600 with center crop imgx fill photo.jpg -w 800 -h 600 -o output.jpg # Fill with top-left anchor imgx fill photo.jpg -w 800 -h 600 --anchor topleft -o output.jpg","title":"fill - Crop and resize to exact dimensions"},{"location":"CLI/#thumbnail-create-square-thumbnail","text":"Create a square thumbnail by cropping and resizing. imgx thumbnail <input> -s <size> [ options ] Options: - -s, --size <int> - Thumbnail size (width and height) (required) - -f, --filter <name> - Resampling filter (default: lanczos) Example: imgx thumbnail photo.jpg -s 150 -o thumb.jpg","title":"thumbnail - Create square thumbnail"},{"location":"CLI/#transform-operations","text":"","title":"Transform Operations"},{"location":"CLI/#rotate-rotate-by-angle","text":"Rotate an image by the specified angle in degrees. Positive angles rotate counter-clockwise, negative angles rotate clockwise. Rotations of 90, 180, and 270 degrees are lossless. imgx rotate <input> -a <angle> [ options ] Options: - -a, --angle <float> - Rotation angle in degrees (required) - --bg <color> - Background color for empty areas (default: 00000000 = transparent) Color Format: RGB hex ( ffffff ) or RGBA hex ( ff0000ff ) Examples: # Rotate 90 degrees counter-clockwise imgx rotate photo.jpg -a 90 -o output.jpg # Rotate 45 degrees with white background imgx rotate photo.jpg -a 45 --bg ffffff -o output.jpg # Rotate 30 degrees clockwise (negative angle) imgx rotate photo.jpg -a -30 -o output.jpg","title":"rotate - Rotate by angle"},{"location":"CLI/#quick-rotation-commands","text":"For common rotations, use these shortcuts: # 90 degrees counter-clockwise imgx rotate90 photo.jpg -o output.jpg # 180 degrees imgx rotate180 photo.jpg -o output.jpg # 270 degrees counter-clockwise (90 clockwise) imgx rotate270 photo.jpg -o output.jpg","title":"Quick Rotation Commands"},{"location":"CLI/#flip-flip-horizontally-or-vertically","text":"Flip an image horizontally (left-right), vertically (top-bottom), or both. imgx flip <input> [ options ] Options: - --horizontal, -H - Flip horizontally (left-right) - --vertical, -V - Flip vertically (top-bottom) Examples: # Flip horizontally imgx flip photo.jpg --horizontal -o output.jpg # Flip vertically imgx flip photo.jpg --vertical -o output.jpg # Flip both (same as rotate 180) imgx flip photo.jpg --horizontal --vertical -o output.jpg","title":"flip - Flip horizontally or vertically"},{"location":"CLI/#crop-crop-to-region","text":"Crop an image to a specific region using either anchor positioning or exact coordinates. imgx crop <input> -w <width> -h <height> [ options ] Options: - -w, --width <int> - Crop width (required) - -h, --height <int> - Crop height (required) - -a, --anchor <pos> - Anchor position (default: center) - -x <int> - X coordinate (left edge, exclusive with --anchor) - -y <int> - Y coordinate (top edge, exclusive with --anchor) Examples: # Crop 500x400 from center imgx crop photo.jpg -w 500 -h 400 --anchor center -o output.jpg # Crop from specific coordinates imgx crop photo.jpg -x 100 -y 100 -w 500 -h 400 -o output.jpg # Crop from top-left imgx crop photo.jpg -w 500 -h 400 --anchor topleft -o output.jpg","title":"crop - Crop to region"},{"location":"CLI/#transpose-transverse-advanced-transforms","text":"Special transformation operations: # Transpose: flip horizontally + rotate 90\u00b0 CCW imgx transpose photo.jpg -o output.jpg # Transverse: flip vertically + rotate 90\u00b0 CCW imgx transverse photo.jpg -o output.jpg","title":"transpose / transverse - Advanced transforms"},{"location":"CLI/#color-adjustments","text":"","title":"Color Adjustments"},{"location":"CLI/#adjust-adjust-colors","text":"Adjust various color properties of an image. Multiple adjustments can be applied at once and are processed in order: brightness \u2192 contrast \u2192 gamma \u2192 saturation \u2192 hue. imgx adjust <input> [ options ] Options: - --brightness <float> - Brightness adjustment (-100 to 100, 0 = no change) - --contrast <float> - Contrast adjustment (-100 to 100, 0 = no change) - --gamma <float> - Gamma correction (positive number, 1.0 = no change) - --saturation <float> - Saturation adjustment (-100 to 100, 0 = no change) - --hue <float> - Hue shift in degrees (-180 to 180, 0 = no change) Examples: # Increase brightness and contrast imgx adjust photo.jpg --brightness 10 --contrast 20 -o output.jpg # Adjust saturation and hue imgx adjust photo.jpg --saturation -30 --hue 60 -o output.jpg # Apply gamma correction imgx adjust photo.jpg --gamma 1 .5 -o output.jpg # Multiple adjustments at once imgx adjust photo.jpg --brightness 10 --contrast 15 --saturation 20 --gamma 1 .2 -o output.jpg","title":"adjust - Adjust colors"},{"location":"CLI/#grayscale-convert-to-grayscale","text":"Convert an image to grayscale using ITU-R BT.601 luminance weights. imgx grayscale <input> [ options ] Example: imgx grayscale photo.jpg -o output.jpg","title":"grayscale - Convert to grayscale"},{"location":"CLI/#invert-invert-colors","text":"Invert (negate) all colors in the image to create a negative effect. imgx invert <input> [ options ] Example: imgx invert photo.jpg -o output.jpg","title":"invert - Invert colors"},{"location":"CLI/#effects","text":"","title":"Effects"},{"location":"CLI/#blur-gaussian-blur","text":"Apply a Gaussian blur effect to the image. Higher sigma values produce stronger blur. imgx blur <input> -s <sigma> [ options ] Options: - -s, --sigma <float> - Blur strength (required, positive number, typical: 0.5-10) Examples: # Subtle blur imgx blur photo.jpg --sigma 1 .5 -o output.jpg # Strong blur imgx blur photo.jpg -s 5 .0 -o output.jpg","title":"blur - Gaussian blur"},{"location":"CLI/#sharpen-sharpen-image","text":"Sharpen the image using unsharp masking. Higher sigma values produce stronger sharpening. imgx sharpen <input> -s <sigma> [ options ] Options: - -s, --sigma <float> - Sharpening strength (required, positive number, typical: 0.5-5) Examples: # Moderate sharpening imgx sharpen photo.jpg --sigma 1 .5 -o output.jpg # Strong sharpening imgx sharpen photo.jpg -s 3 .0 -o output.jpg","title":"sharpen - Sharpen image"},{"location":"CLI/#watermarking","text":"","title":"Watermarking"},{"location":"CLI/#watermark-add-text-watermark","text":"Add a text watermark to an image with configurable position, opacity, color, and padding. imgx watermark <input> -t <text> [ options ] Options: - -t, --text <string> - Watermark text (required) - --opacity <float> - Opacity (0.0 to 1.0, default: 0.5) - -a, --anchor <pos> - Position (default: bottomright) - --color <color> - Text color in hex (default: ffffff = white) - --padding <int> - Padding from edges in pixels (default: 10) Color Format: RGB hex ( ffffff ) or RGBA hex ( ff0000ff ) Examples: # Simple copyright watermark imgx watermark photo.jpg --text \"Copyright 2025\" -o output.jpg # Draft watermark in center with red color imgx watermark photo.jpg --text \"DRAFT\" --opacity 0 .3 --anchor center --color ff0000 -o output.jpg # Top-left watermark with custom padding imgx watermark photo.jpg --text \"Sample\" --anchor topleft --padding 20 -o output.jpg # Semi-transparent watermark with RGBA color imgx watermark photo.jpg --text \"Watermark\" --color ff000080 -o output.jpg","title":"watermark - Add text watermark"},{"location":"CLI/#image-information","text":"","title":"Image Information"},{"location":"CLI/#info-display-image-information","text":"Display detailed information about an image file. imgx info <input> [ options ] Options: - -e, --extended - Show extended metadata (requires exiftool) Output includes: - File path - Image format (JPEG, PNG, GIF, TIFF, BMP) - Dimensions (width \u00d7 height) - File size - Color model With --extended flag (requires exiftool): - Camera information and settings - GPS location data - Date/time metadata - Copyright and authorship Examples: # Basic info imgx info photo.jpg # Extended metadata imgx info photo.jpg --extended Sample basic output: File: photo.jpg Format: JPEG Dimensions: 1920x1080 Size: 245.3 KB Color Model: *color.modelFunc Sample extended output: File: photo.jpg Format: JPEG Dimensions: 1920x1080 Size: 245.3 KB Color Model: *color.modelFunc Camera: Make: Canon Model: Canon EOS 5D Mark IV Date Taken: 2024:10:15 14:23:45 Settings: Focal Length: 50.0 mm Aperture: f/1.8 ISO: 400","title":"info - Display image information"},{"location":"CLI/#metadata-extract-comprehensive-metadata","text":"Extract and display comprehensive image metadata including EXIF, IPTC, and XMP data. imgx metadata <input> [ options ] Options: - -b, --basic - Show basic metadata only (skip exiftool) - -j, --json - Output metadata as JSON Features: When exiftool is installed , displays: - Camera Information: Make, model, lens - Camera Settings: ISO, aperture (f-number), shutter speed, focal length, flash - GPS Location: Latitude, longitude, altitude - Date/Time: Original capture date, modification date - Additional Info: Software, artist, copyright - File Details: Format, dimensions, aspect ratio, megapixels, file size, color model When exiftool is NOT installed , displays basic metadata: - File path, format, and size - Image dimensions and aspect ratio - Megapixels and color model - Warning message with installation instructions Examples: # Display all available metadata imgx metadata photo.jpg # Show basic metadata only (skip exiftool) imgx metadata photo.jpg --basic # Output as JSON for parsing imgx metadata photo.jpg --json > metadata.json Sample output (with exiftool): === Image Metadata === File Information: Path: photo.jpg Format: JPEG Size: 2.3 MB Image Properties: Dimensions: 4000x3000 Aspect Ratio: 1.33 Megapixels: 12.00 MP Color Model: *color.modelFunc Camera Information: Make: Canon Model: Canon EOS 5D Mark IV Lens: EF50mm f/1.8 STM Camera Settings: Focal Length: 50.0 mm Aperture: f/1.8 Shutter: 1/250 ISO: 400 Flash: No Flash Date/Time: Original: 2024:10:15 14:23:45 Modified: 2024:10:20 09:15:30 GPS Location: Latitude: 37.7749 N Longitude: 122.4194 W Altitude: 15.0 m Additional Information: Software: Adobe Photoshop CC 2024 Copyright: \u00a9 2024 John Doe Sample output (without exiftool): === Image Metadata === File Information: Path: photo.jpg Format: JPEG Size: 2.3 MB Image Properties: Dimensions: 4000x3000 Aspect Ratio: 1.33 Megapixels: 12.00 MP Color Model: *color.modelFunc --- exiftool not found. Install exiftool for comprehensive metadata. Installation: macOS: brew install exiftool Ubuntu: sudo apt-get install libimage-exiftool-perl Windows: https://exiftool.org JSON Output Example: imgx metadata photo.jpg --json { \"FilePath\" : \"photo.jpg\" , \"Format\" : \"JPEG\" , \"Width\" : 4000 , \"Height\" : 3000 , \"FileSize\" : 2415919 , \"Megapixels\" : 12.00 , \"AspectRatio\" : 1.33 , \"HasExtended\" : true , \"CameraMake\" : \"Canon\" , \"CameraModel\" : \"Canon EOS 5D Mark IV\" , \"ISO\" : \"400\" , \"FocalLength\" : \"50.0 mm\" , \"DateTimeOriginal\" : \"2024:10:15 14:23:45\" } Installing exiftool: # macOS brew install exiftool # Ubuntu/Debian sudo apt-get install libimage-exiftool-perl # Fedora/RHEL sudo dnf install perl-Image-ExifTool # Windows # Download from https://exiftool.org and add to PATH # Verify installation exiftool -ver","title":"metadata - Extract comprehensive metadata"},{"location":"CLI/#object-detection","text":"","title":"Object Detection"},{"location":"CLI/#detect-ai-powered-object-detection","text":"Detect objects, text, faces, and image properties using local Ollama models or cloud AI vision APIs (Google Gemini, AWS Rekognition, OpenAI Vision). imgx detect <input> [ options ] Options: - -p, --provider string - Detection provider: ollama , gemini , google (alias), aws , openai (default: ollama ) - -f, --features string - Features to detect: labels,text,faces,web,description,properties (comma-separated, default: labels ) - -m, --max-results int - Maximum number of labels to return (default: 10) - -c, --confidence float - Minimum confidence threshold 0.0-1.0 (default: 0.5) - --prompt string - Custom prompt for Ollama/Gemini/OpenAI (overrides --features) - -j, --json - Output results as JSON (includes colors, quality, moderation when available) - --raw - Include raw API response in output Supported Providers: - ollama (local multimodal models) - Requires ollama serve plus local model (default gemma3 ) - gemini (Google Gemini API) - Requires GEMINI_API_KEY - aws (AWS Rekognition) - Requires AWS credentials - openai (OpenAI Vision) - Requires OPENAI_API_KEY Setup: # Ollama: run the local server and pull a model ollama serve & ollama pull gemma3 # Optional overrides export OLLAMA_HOST = \"http://127.0.0.1:11434\" export IMGX_OLLAMA_MODEL = \"llava\" # Gemini: Get API key from https://aistudio.google.com/ export GEMINI_API_KEY = \"your-api-key\" # AWS: Configure via AWS CLI or environment variables aws configure # OR export AWS_ACCESS_KEY_ID = \"your-key\" export AWS_SECRET_ACCESS_KEY = \"your-secret\" export AWS_REGION = \"us-east-1\" # OpenAI: Get API key from https://platform.openai.com/ export OPENAI_API_KEY = \"sk-...\" Available Features: - labels - Detect objects and labels - text - Extract text (OCR) - faces - Detect faces and attributes - description - Get natural language description (Ollama/Gemini/OpenAI) - web - Web entities and similar images (Gemini only) - landmarks - Detect famous landmarks (Gemini only) - properties - Image quality, colors, sharpness (Ollama/AWS) - safesearch - Content moderation Examples: # Basic detection with the local Ollama model (default) imgx detect photo.jpg # Use specific provider imgx detect photo.jpg --provider aws # Multiple features imgx detect document.jpg --features labels,text,faces # AWS image properties (colors, quality) imgx detect photo.jpg --provider aws --features properties # AWS labels + properties (charged for both) imgx detect photo.jpg --provider aws --features labels,properties # Custom prompt with Ollama or Gemini imgx detect dog.jpg --prompt \"What breed is this dog?\" # Higher confidence threshold imgx detect photo.jpg --confidence 0 .8 # JSON output imgx detect photo.jpg --json # Compare providers imgx detect photo.jpg --provider ollama imgx detect photo.jpg --provider gemini imgx detect photo.jpg --provider aws imgx detect photo.jpg --provider openai Sample Output (pretty format): === Object Detection Results (aws) === Labels: 1. Dog (99.0% confidence) 2. Pet (97.6% confidence) 3. Animal (96.3% confidence) Detected Text: 1. \"Backyard\" (88.0% confidence) Properties: brightness: 84.50 contrast: 76.20 foreground_color: Green Dominant Colors: - Green (#8FB94B, rgb(143,185,75), 41.3%) - Brown (#6B4E2E, rgb(107,78,46), 18.6%) Image Quality: Brightness: 84.50 Contrast: 76.20 Sharpness: 80.10 Foreground: Brightness: 81.20 Color: Green Moderation: - Violence (severity: VERY_UNLIKELY, confidence: 0.5%) Safe Search Summary: - Violence (VERY_UNLIKELY, 0.5%) Overall Confidence: 97.6% Processed at: 2024-11-01 16:30:45 JSON Output Example: { \"provider\" : \"gemini\" , \"labels\" : [ { \"name\" : \"Dog\" , \"confidence\" : 0.985 , \"categories\" : [ \"Animal\" , \"Pet\" ] }, { \"name\" : \"Golden Retriever\" , \"confidence\" : 0.942 , \"categories\" : [ \"Dog\" , \"Breed\" ] } ], \"confidence\" : 0.934 , \"processed_at\" : \"2024-11-01T16:30:45Z\" } AWS Image Properties Output: imgx detect photo.jpg --provider aws --features properties # Output: Provider: aws Processed: 2024 -11-01 16 :30:45 Image Properties: brightness: 75 .23 sharpness: 89 .15 contrast: 62 .45 dominant_colors: Black ( 45 .2% ) , White ( 23 .1% ) , Blue ( 15 .7% ) color_1_hex: #0C0F12 color_1_rgb: rgb ( 12 ,15,18 ) color_2_hex: #F5F5F5 color_2_rgb: rgb ( 245 ,245,245 ) foreground_color: Black background_color: White Text Extraction Example: imgx detect document.jpg --features text # Output: Provider: gemini Processed: 2024 -11-01 16 :30:45 Text Detected: - \"Invoice\" ( confidence: 99 .2% ) - \"Total: $152 .50\" ( confidence: 98 .7% ) - \"Date: 2024-10-15\" ( confidence: 97 .5% ) Face Detection Example: imgx detect group-photo.jpg --features faces # Output: Provider: aws Processed: 2024 -11-01 16 :30:45 Faces Detected: 3 Face 1 : confidence 99 .8%, age 25 -35, smiling Face 2 : confidence 99 .5%, age 30 -40, neutral Face 3 : confidence 98 .9%, age 20 -30, happy Pricing Notes: Gemini : Free tier available, then pay-as-you-go AWS Rekognition : --features labels \u2192 Standard DetectLabels pricing (~$0.001/image) --features properties \u2192 Image Properties pricing only --features labels,properties \u2192 Charged for BOTH APIs OpenAI Vision : Per-request pricing based on GPT-4o Troubleshooting: # Test Gemini credentials echo $GEMINI_API_KEY # Test AWS credentials aws sts get-caller-identity # Test OpenAI credentials echo $OPENAI_API_KEY See Also: - Detailed API documentation: docs/DETECTION.md - Example code: examples/detection/main.go","title":"detect - AI-powered object detection"},{"location":"CLI/#common-use-cases","text":"","title":"Common Use Cases"},{"location":"CLI/#web-optimization","text":"# Resize for web and optimize JPEG quality imgx resize photo.jpg -w 1200 --quality 85 -o web.jpg # Create responsive image set imgx resize photo.jpg -w 1920 -o photo-large.jpg imgx resize photo.jpg -w 1200 -o photo-medium.jpg imgx resize photo.jpg -w 800 -o photo-small.jpg","title":"Web Optimization"},{"location":"CLI/#social-media","text":"# Instagram post (1080x1080) imgx fill photo.jpg -w 1080 -h 1080 -o instagram.jpg # Facebook cover (1200x630) imgx fill photo.jpg -w 1200 -h 630 -o facebook-cover.jpg # Twitter header (1500x500) imgx fill photo.jpg -w 1500 -h 500 -o twitter-header.jpg","title":"Social Media"},{"location":"CLI/#photo-enhancement","text":"# Quick enhancement imgx adjust photo.jpg --brightness 5 --contrast 10 --saturation 15 -o enhanced.jpg # Fix dark photo imgx adjust photo.jpg --brightness 20 --gamma 1 .3 -o brightened.jpg # Boost colors imgx adjust photo.jpg --saturation 25 --contrast 10 -o vibrant.jpg","title":"Photo Enhancement"},{"location":"CLI/#thumbnails","text":"# Square thumbnails imgx thumbnail photo.jpg -s 150 -o thumb-150.jpg imgx thumbnail photo.jpg -s 300 -o thumb-300.jpg # Preserve aspect ratio thumbnails imgx resize photo.jpg -w 300 -o thumb.jpg","title":"Thumbnails"},{"location":"CLI/#watermarking_1","text":"# Copyright watermark imgx watermark photo.jpg --text \"\u00a9 2025 Your Name\" --opacity 0 .4 -o watermarked.jpg # Draft stamp imgx watermark document.jpg --text \"DRAFT\" --anchor center --opacity 0 .3 --color ff0000 -o draft.jpg # Bottom-left attribution imgx watermark photo.jpg --text \"Photo by You\" --anchor bottomleft --padding 15 -o attributed.jpg","title":"Watermarking"},{"location":"CLI/#creative-effects","text":"# Soft focus effect imgx blur photo.jpg --sigma 3 .0 -o soft-focus.jpg # High contrast black and white imgx grayscale photo.jpg -o bw.jpg imgx adjust bw.jpg --contrast 30 -o high-contrast-bw.jpg # Vintage look imgx adjust photo.jpg --saturation -20 --contrast -10 --gamma 1 .2 -o vintage.jpg # Inverted colors (negative) imgx invert photo.jpg -o negative.jpg","title":"Creative Effects"},{"location":"CLI/#tips-tricks","text":"","title":"Tips &amp; Tricks"},{"location":"CLI/#auto-generated-output-names","text":"If you don't specify an output file with -o , imgx automatically generates one by adding a suffix: imgx resize photo.jpg -w 800 # Creates: photo-resized.jpg imgx thumbnail photo.jpg -s 150 # Creates: photo-thumb.jpg imgx grayscale photo.jpg # Creates: photo-grayscale.jpg","title":"Auto-generated Output Names"},{"location":"CLI/#format-conversion","text":"Convert between formats using the --format flag: # PNG to JPEG imgx resize photo.png -w 800 --format jpg --quality 90 -o output.jpg # JPEG to PNG imgx resize photo.jpg -w 800 --format png -o output.png","title":"Format Conversion"},{"location":"CLI/#preserving-quality","text":"For JPEG output, use high quality settings to preserve detail: # High quality (larger file) imgx resize photo.jpg -w 1920 --quality 95 -o output.jpg # Balanced quality imgx resize photo.jpg -w 1920 --quality 85 -o output.jpg # Web optimized imgx resize photo.jpg -w 1920 --quality 75 -o output.jpg","title":"Preserving Quality"},{"location":"CLI/#chaining-operations","text":"While command chaining is planned for a future release, you can currently chain operations using shell pipes or by saving intermediate files: # Method 1: Multiple commands imgx resize photo.jpg -w 800 -o temp.jpg imgx adjust temp.jpg --brightness 10 --contrast 20 -o final.jpg rm temp.jpg # Method 2: Multiple adjustments in one command imgx adjust photo.jpg --brightness 10 --contrast 20 --saturation 15 -o adjusted.jpg","title":"Chaining Operations"},{"location":"CLI/#verbose-mode","text":"Use verbose mode ( -v ) to see what operations are being performed: imgx adjust photo.jpg --brightness 10 --contrast 20 -v -o output.jpg # Output: # Loaded: photo.jpg (1920x1080) # Applying brightness: 10.0 # Applying contrast: 20.0 # Saving: output.jpg (1920x1080) # Saved: output.jpg","title":"Verbose Mode"},{"location":"CLI/#resampling-filters","text":"Choose the right filter for your use case: Lanczos (default): Best quality for most photographic images CatmullRom : Fast, sharp results similar to Lanczos MitchellNetravali : Smoother results with less ringing Linear : Fast bilinear resampling, good for quick previews Box : Fast averaging, good for downscaling Nearest : Fastest, no antialiasing (pixelated for photos) # High quality photographic resize imgx resize photo.jpg -w 800 -f lanczos -o output.jpg # Fast resize for previews imgx resize photo.jpg -w 800 -f linear -o preview.jpg # Pixel art (no smoothing) imgx resize pixelart.png -w 800 -f nearest -o scaled-pixelart.png","title":"Resampling Filters"},{"location":"CLI/#getting-help","text":"imgx provides comprehensive help at every level.","title":"Getting Help"},{"location":"CLI/#general-help","text":"# Show all commands imgx --help imgx -h # Version information imgx --version","title":"General Help"},{"location":"CLI/#command-specific-help","text":"There are two ways to get help for a specific command: Method 1: help before the command name imgx help resize imgx help adjust imgx help watermark Method 2: --help flag after the command name (also shows global options) imgx resize --help imgx adjust --help imgx watermark --help Note: Don't use imgx <command> help (help after the command) - this syntax doesn't work correctly.","title":"Command-Specific Help"},{"location":"CLI/#shell-completion-scripts","text":"imgx completion bash imgx completion zsh imgx completion fish imgx completion pwsh","title":"Shell Completion Scripts"},{"location":"CLI/#exit-codes","text":"0 - Success 1 - Error (invalid arguments, file not found, processing error, etc.)","title":"Exit Codes"},{"location":"CLI/#supported-formats","text":"Input formats: JPEG, PNG, GIF, TIFF, BMP Output formats: JPEG, PNG, GIF, TIFF, BMP Format is automatically detected from file extension or can be forced with --format flag.","title":"Supported Formats"},{"location":"DETECTION/","text":"Image Detection API Documentation \u00b6 Advanced AI-powered object detection for images using local Ollama models, Google Gemini, AWS Rekognition, and OpenAI Vision APIs. Table of Contents \u00b6 Overview Supported Providers Setup & Authentication Quick Start Detection Features API Reference Examples Best Practices Pricing Considerations Troubleshooting Overview \u00b6 The detection package provides a unified interface for multiple AI vision providers, allowing you to: - Detect objects and labels in images - Extract text (OCR) - Detect faces and facial attributes - Analyze image properties (colors, quality, sharpness) - Check for inappropriate content - Get natural language descriptions All providers return results in a consistent format, making it easy to switch between providers or compare results. Supported Providers \u00b6 Provider API Key Required Features Ollama (default) None (local server) Labels, Text, Faces, Description, Moderation Google Gemini GEMINI_API_KEY Labels, Text, Faces, Description, Web detection, Landmarks AWS Rekognition AWS credentials Labels, Text, Faces, Image Properties, Moderation OpenAI Vision OPENAI_API_KEY Labels, Description, Text, Faces (via GPT-4o) Setup & Authentication \u00b6 Ollama (Local) \u00b6 Install Ollama and start the daemon: ollama serve Pull the default multimodal model: ollama pull gemma3 (Optional) Override the host or model: export OLLAMA_HOST = \"http://192.168.1.50:11434\" export IMGX_OLLAMA_MODEL = \"llava\" Google Gemini \u00b6 Get API key from Google AI Studio Set environment variable: export GEMINI_API_KEY = \"your-api-key\" AWS Rekognition \u00b6 AWS uses the standard credential chain: Option 1: Environment Variables export AWS_ACCESS_KEY_ID = \"your-key\" export AWS_SECRET_ACCESS_KEY = \"your-secret\" export AWS_REGION = \"us-east-1\" Option 2: AWS CLI Configuration aws configure Option 3: AWS Profile export AWS_PROFILE = \"myprofile\" Option 4: IAM Roles (automatic on EC2/ECS/Lambda) OpenAI Vision \u00b6 Get API key from OpenAI Platform Set environment variable: export OPENAI_API_KEY = \"sk-...\" Quick Start \u00b6 package main import ( \"context\" \"fmt\" \"log\" \"github.com/razzkumar/imgx\" ) func main () { // Load an image img , err := imgx . Load ( \"photo.jpg\" ) if err != nil { log . Fatal ( err ) } // Detect objects using the default local Ollama model ctx := context . Background () result , err := img . Detect ( ctx , \"ollama\" ) if err != nil { log . Fatal ( err ) } // Print detected labels fmt . Println ( \"Detected objects:\" ) for _ , label := range result . Labels { fmt . Printf ( \"- %s (%.1f%% confidence)\\n\" , label . Name , label . Confidence * 100 ) } } Detection Features \u00b6 Available Features \u00b6 const ( FeatureLabels Feature = \"labels\" // Object/label detection FeatureObjects Feature = \"objects\" // Alias for labels FeatureText Feature = \"text\" // OCR text extraction FeatureFaces Feature = \"faces\" // Face detection FeatureDescription Feature = \"description\" // Natural language description FeatureWeb Feature = \"web\" // Web entities (Gemini only) FeatureLandmarks Feature = \"landmarks\" // Landmark detection (Gemini only) FeatureProperties Feature = \"properties\" // Image properties (AWS only) FeatureSafeSearch Feature = \"safesearch\" // Content moderation ) Feature Support Matrix \u00b6 Feature Ollama Gemini AWS OpenAI Labels \u2705 \u2705 \u2705 \u2705 Text (OCR) \u2705 \u2705 \u2705 \u2705 Faces \u2705 \u2705 \u2705 \u2705 Description \u2705 \u2705 \u274c \u2705 Web Detection \u274c \u2705 \u274c \u274c Landmarks \u274c \u2705 \u274c \u274c Properties \u2705 \u274c \u2705 \u274c SafeSearch/Moderation \u2705 \u2705 \u2705 \u2705 API Reference \u00b6 Core Types \u00b6 DetectionResult \u00b6 type DetectionResult struct { Provider string // Provider used (ollama, gemini, aws, openai) Labels [] Label // Detected objects/labels Description string // Natural language description Text [] TextBlock // Extracted text Faces [] Face // Detected faces Web * WebDetection // Web entities (Gemini) BoundingBoxes [] BoundingBox // Object locations Properties map [ string ] string // Image properties (AWS) Confidence float32 // Overall confidence (0.0-1.0) ProcessedAt time . Time // Processing timestamp RawResponse string // Raw API response (if requested) } Label \u00b6 type Label struct { Name string // Label name (e.g., \"Dog\", \"Car\") Confidence float32 // Confidence score (0.0-1.0) Categories [] string // Parent categories } TextBlock \u00b6 type TextBlock struct { Text string // Extracted text Confidence float32 // Confidence score (0.0-1.0) BoundingBox * BoundingBox // Text location Language string // Detected language (if available) } Face \u00b6 type Face struct { Confidence float32 // Confidence score (0.0-1.0) BoundingBox * BoundingBox // Face location Landmarks [] FaceLandmark // Facial landmarks (eyes, nose, etc.) Emotions map [ string ] float32 // Emotion scores AgeRange string // Estimated age range Gender string // Detected gender } Detection Options \u00b6 type DetectOptions struct { Features [] Feature // Features to detect MaxResults int // Maximum labels to return (default: 10) MinConfidence float32 // Minimum confidence threshold (0.0-1.0, default: 0.5) CustomPrompt string // Custom prompt (Gemini/OpenAI) IncludeRawResponse bool // Include raw API response } // Create default options opts := detection . DefaultDetectOptions () // Customize options opts := & detection . DetectOptions { Features : [] detection . Feature { detection . FeatureLabels , detection . FeatureText }, MaxResults : 20 , MinConfidence : 0.7 , } Methods \u00b6 Image.Detect() \u00b6 func ( img * Image ) Detect ( ctx context . Context , provider string , opts ...* detection . DetectOptions ) ( * detection . DetectionResult , error ) High-level method on *imgx.Image instances. Parameters: - ctx : Context for cancellation and timeouts - provider : Provider name (\"ollama\", \"gemma3\", \"qwen3-vl\", \"gemini\", \"google\", \"aws\", \"rekognition\", \"openai\") - opts : Optional detection options Returns: - *DetectionResult : Detection results - error : Error if detection fails Provider Interface \u00b6 type Provider interface { Detect ( ctx context . Context , img * image . NRGBA , opts * DetectOptions ) ( * DetectionResult , error ) Name () string IsConfigured () bool } Direct provider access for advanced use cases: provider , err := detection . GetProvider ( \"ollama\" ) if err != nil { log . Fatal ( err ) } result , err := provider . Detect ( ctx , img . ToNRGBA (), opts ) Examples \u00b6 Basic Detection \u00b6 img , _ := imgx . Load ( \"photo.jpg\" ) ctx := context . Background () result , err := img . Detect ( ctx , \"ollama\" ) if err != nil { log . Fatal ( err ) } for _ , label := range result . Labels { fmt . Printf ( \"%s: %.1f%%\\n\" , label . Name , label . Confidence * 100 ) } Multiple Features \u00b6 opts := & detection . DetectOptions { Features : [] detection . Feature { detection . FeatureLabels , detection . FeatureText , detection . FeatureFaces , }, MaxResults : 15 , MinConfidence : 0.7 , } result , err := img . Detect ( ctx , \"aws\" , opts ) if err != nil { log . Fatal ( err ) } // Labels fmt . Println ( \"Objects:\" , len ( result . Labels )) // Text extraction fmt . Println ( \"Text found:\" ) for _ , text := range result . Text { fmt . Printf ( \"- %s\\n\" , text . Text ) } // Faces fmt . Printf ( \"Found %d faces\\n\" , len ( result . Faces )) AWS Image Properties \u00b6 // Get image quality metrics and dominant colors opts := & detection . DetectOptions { Features : [] detection . Feature { detection . FeatureProperties }, } result , err := img . Detect ( ctx , \"aws\" , opts ) if err != nil { log . Fatal ( err ) } // Access properties fmt . Println ( \"Brightness:\" , result . Properties [ \"brightness\" ]) fmt . Println ( \"Sharpness:\" , result . Properties [ \"sharpness\" ]) fmt . Println ( \"Contrast:\" , result . Properties [ \"contrast\" ]) fmt . Println ( \"Dominant colors:\" , result . Properties [ \"dominant_colors\" ]) fmt . Println ( \"Color 1 (hex):\" , result . Properties [ \"color_1_hex\" ]) fmt . Println ( \"Color 1 (rgb):\" , result . Properties [ \"color_1_rgb\" ]) Custom Prompt (Gemini/OpenAI) \u00b6 opts := & detection . DetectOptions { CustomPrompt : \"Is there a dog in this image? What breed might it be?\" , } result , err := img . Detect ( ctx , \"gemini\" , opts ) if err != nil { log . Fatal ( err ) } fmt . Println ( \"Description:\" , result . Description ) Compare Multiple Providers \u00b6 providers := [] string { \"gemini\" , \"aws\" , \"openai\" } for _ , provider := range providers { result , err := img . Detect ( ctx , provider ) if err != nil { fmt . Printf ( \"%s error: %v\\n\" , provider , err ) continue } fmt . Printf ( \"\\n%s results:\\n\" , strings . ToUpper ( provider )) for _ , label := range result . Labels [: 5 ] { fmt . Printf ( \" - %s (%.1f%%)\\n\" , label . Name , label . Confidence * 100 ) } } Error Handling \u00b6 result , err := img . Detect ( ctx , \"aws\" ) if err != nil { // Check for specific error types if errors . Is ( err , detection . ErrProviderNotConfigured ) { log . Fatal ( \"AWS credentials not configured. Run: aws configure\" ) } // Check error message for details if strings . Contains ( err . Error (), \"invalid credentials\" ) { log . Fatal ( \"AWS credentials are invalid or expired\" ) } log . Fatal ( err ) } With Context Timeout \u00b6 // Set 10 second timeout ctx , cancel := context . WithTimeout ( context . Background (), 10 * time . Second ) defer cancel () result , err := img . Detect ( ctx , \"gemini\" ) if err != nil { if errors . Is ( err , context . DeadlineExceeded ) { log . Fatal ( \"Detection timed out\" ) } log . Fatal ( err ) } Batch Processing \u00b6 images := [] string { \"photo1.jpg\" , \"photo2.jpg\" , \"photo3.jpg\" } ctx := context . Background () for _ , imagePath := range images { img , err := imgx . Load ( imagePath ) if err != nil { log . Printf ( \"Failed to load %s: %v\" , imagePath , err ) continue } result , err := img . Detect ( ctx , \"gemini\" ) if err != nil { log . Printf ( \"Failed to detect %s: %v\" , imagePath , err ) continue } fmt . Printf ( \"\\n%s:\\n\" , imagePath ) for i , label := range result . Labels { if i >= 3 { break } // Top 3 labels fmt . Printf ( \" %s (%.1f%%)\\n\" , label . Name , label . Confidence * 100 ) } } Best Practices \u00b6 1. Choose the Right Provider \u00b6 Gemini : Best for general-purpose detection, custom prompts, and web entity detection AWS Rekognition : Best for production workloads, image properties, and when you need reliable face detection OpenAI Vision : Best for natural language descriptions and when you need GPT-4o's reasoning 2. Set Appropriate Confidence Thresholds \u00b6 // For critical applications, use higher confidence opts := & detection . DetectOptions { MinConfidence : 0.8 , // Only high-confidence results } // For exploratory analysis, use lower confidence opts := & detection . DetectOptions { MinConfidence : 0.3 , // Catch more possibilities } 3. Handle Rate Limits \u00b6 import \"time\" for _ , img := range images { result , err := img . Detect ( ctx , \"gemini\" ) if err != nil { if strings . Contains ( err . Error (), \"rate limit\" ) { time . Sleep ( 2 * time . Second ) result , err = img . Detect ( ctx , \"gemini\" ) // Retry } if err != nil { log . Printf ( \"Error: %v\" , err ) continue } } // Process result... } 4. Use Context for Cancellation \u00b6 ctx , cancel := context . WithCancel ( context . Background ()) // Cancel on Ctrl+C go func () { sigChan := make ( chan os . Signal , 1 ) signal . Notify ( sigChan , os . Interrupt ) <- sigChan cancel () }() result , err := img . Detect ( ctx , \"gemini\" ) 5. Cache Results \u00b6 type DetectionCache struct { mu sync . RWMutex cache map [ string ] * detection . DetectionResult } func ( c * DetectionCache ) Get ( key string ) ( * detection . DetectionResult , bool ) { c . mu . RLock () defer c . mu . RUnlock () result , ok := c . cache [ key ] return result , ok } func ( c * DetectionCache ) Set ( key string , result * detection . DetectionResult ) { c . mu . Lock () defer c . mu . Unlock () c . cache [ key ] = result } Pricing Considerations \u00b6 AWS Rekognition \u00b6 Important : The properties feature has separate pricing. Labels only : --features labels \u2192 Standard DetectLabels pricing Properties only : --features properties \u2192 Image Properties pricing only Both : --features labels,properties \u2192 Charged for BOTH APIs Example costs (as of 2024): - DetectLabels: ~$0.001 per image (first 1M images/month) - Image Properties: Additional charge when combined with labels - DetectText, DetectFaces: Separate pricing Recommendation : Only request properties when needed to minimize costs. Gemini \u00b6 Free tier available with rate limits Pay-as-you-go pricing after free tier Custom prompts may use more tokens OpenAI Vision \u00b6 Charged per API call GPT-4o has different pricing than GPT-4 Image size affects cost Troubleshooting \u00b6 Common Issues \u00b6 1. \"Provider not configured\" \u00b6 Gemini: # Check if key is set echo $GEMINI_API_KEY # Set the key export GEMINI_API_KEY = \"your-key\" AWS: # Test credentials aws sts get-caller-identity # If that fails, run aws configure OpenAI: # Check if key is set echo $OPENAI_API_KEY # Set the key export OPENAI_API_KEY = \"sk-...\" 2. \"Invalid AWS credentials\" \u00b6 This error means your AWS credentials are incorrect or expired. # Verify credentials are correct aws sts get-caller-identity # If using temporary credentials, they may have expired # Get new credentials from your IAM administrator # Check which credential source is being used AWS_PROFILE = default aws sts get-caller-identity 3. \"Access denied\" (AWS) \u00b6 Your IAM user/role lacks necessary permissions. Required IAM permissions: { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : [ \"rekognition:DetectLabels\" , \"rekognition:DetectText\" , \"rekognition:DetectFaces\" , \"rekognition:DetectModerationLabels\" ], \"Resource\" : \"*\" } ] } 4. Rate Limiting \u00b6 If you hit rate limits, implement exponential backoff: func detectWithRetry ( img * imgx . Image , ctx context . Context , provider string ) ( * detection . DetectionResult , error ) { maxRetries := 3 baseDelay := time . Second for i := 0 ; i < maxRetries ; i ++ { result , err := img . Detect ( ctx , provider ) if err == nil { return result , nil } if ! strings . Contains ( err . Error (), \"rate limit\" ) { return nil , err } if i < maxRetries - 1 { delay := baseDelay * time . Duration ( 1 << uint ( i )) time . Sleep ( delay ) } } return nil , fmt . Errorf ( \"max retries exceeded\" ) } 5. Large Images \u00b6 If you get errors about image size: // Resize large images before detection if img . Bounds (). Dx () > 2048 || img . Bounds (). Dy () > 2048 { img = img . Fit ( 2048 , 2048 , imgx . Lanczos ) } result , err := img . Detect ( ctx , \"gemini\" ) Additional Resources \u00b6 Google Gemini API Documentation AWS Rekognition Documentation OpenAI Vision API Documentation imgx GitHub Repository Example Code See Also \u00b6 CLI Documentation - Command-line usage Main README - Library overview Versioning - Version management","title":"AI Detection"},{"location":"DETECTION/#image-detection-api-documentation","text":"Advanced AI-powered object detection for images using local Ollama models, Google Gemini, AWS Rekognition, and OpenAI Vision APIs.","title":"Image Detection API Documentation"},{"location":"DETECTION/#table-of-contents","text":"Overview Supported Providers Setup & Authentication Quick Start Detection Features API Reference Examples Best Practices Pricing Considerations Troubleshooting","title":"Table of Contents"},{"location":"DETECTION/#overview","text":"The detection package provides a unified interface for multiple AI vision providers, allowing you to: - Detect objects and labels in images - Extract text (OCR) - Detect faces and facial attributes - Analyze image properties (colors, quality, sharpness) - Check for inappropriate content - Get natural language descriptions All providers return results in a consistent format, making it easy to switch between providers or compare results.","title":"Overview"},{"location":"DETECTION/#supported-providers","text":"Provider API Key Required Features Ollama (default) None (local server) Labels, Text, Faces, Description, Moderation Google Gemini GEMINI_API_KEY Labels, Text, Faces, Description, Web detection, Landmarks AWS Rekognition AWS credentials Labels, Text, Faces, Image Properties, Moderation OpenAI Vision OPENAI_API_KEY Labels, Description, Text, Faces (via GPT-4o)","title":"Supported Providers"},{"location":"DETECTION/#setup-authentication","text":"","title":"Setup &amp; Authentication"},{"location":"DETECTION/#ollama-local","text":"Install Ollama and start the daemon: ollama serve Pull the default multimodal model: ollama pull gemma3 (Optional) Override the host or model: export OLLAMA_HOST = \"http://192.168.1.50:11434\" export IMGX_OLLAMA_MODEL = \"llava\"","title":"Ollama (Local)"},{"location":"DETECTION/#google-gemini","text":"Get API key from Google AI Studio Set environment variable: export GEMINI_API_KEY = \"your-api-key\"","title":"Google Gemini"},{"location":"DETECTION/#aws-rekognition","text":"AWS uses the standard credential chain: Option 1: Environment Variables export AWS_ACCESS_KEY_ID = \"your-key\" export AWS_SECRET_ACCESS_KEY = \"your-secret\" export AWS_REGION = \"us-east-1\" Option 2: AWS CLI Configuration aws configure Option 3: AWS Profile export AWS_PROFILE = \"myprofile\" Option 4: IAM Roles (automatic on EC2/ECS/Lambda)","title":"AWS Rekognition"},{"location":"DETECTION/#openai-vision","text":"Get API key from OpenAI Platform Set environment variable: export OPENAI_API_KEY = \"sk-...\"","title":"OpenAI Vision"},{"location":"DETECTION/#quick-start","text":"package main import ( \"context\" \"fmt\" \"log\" \"github.com/razzkumar/imgx\" ) func main () { // Load an image img , err := imgx . Load ( \"photo.jpg\" ) if err != nil { log . Fatal ( err ) } // Detect objects using the default local Ollama model ctx := context . Background () result , err := img . Detect ( ctx , \"ollama\" ) if err != nil { log . Fatal ( err ) } // Print detected labels fmt . Println ( \"Detected objects:\" ) for _ , label := range result . Labels { fmt . Printf ( \"- %s (%.1f%% confidence)\\n\" , label . Name , label . Confidence * 100 ) } }","title":"Quick Start"},{"location":"DETECTION/#detection-features","text":"","title":"Detection Features"},{"location":"DETECTION/#available-features","text":"const ( FeatureLabels Feature = \"labels\" // Object/label detection FeatureObjects Feature = \"objects\" // Alias for labels FeatureText Feature = \"text\" // OCR text extraction FeatureFaces Feature = \"faces\" // Face detection FeatureDescription Feature = \"description\" // Natural language description FeatureWeb Feature = \"web\" // Web entities (Gemini only) FeatureLandmarks Feature = \"landmarks\" // Landmark detection (Gemini only) FeatureProperties Feature = \"properties\" // Image properties (AWS only) FeatureSafeSearch Feature = \"safesearch\" // Content moderation )","title":"Available Features"},{"location":"DETECTION/#feature-support-matrix","text":"Feature Ollama Gemini AWS OpenAI Labels \u2705 \u2705 \u2705 \u2705 Text (OCR) \u2705 \u2705 \u2705 \u2705 Faces \u2705 \u2705 \u2705 \u2705 Description \u2705 \u2705 \u274c \u2705 Web Detection \u274c \u2705 \u274c \u274c Landmarks \u274c \u2705 \u274c \u274c Properties \u2705 \u274c \u2705 \u274c SafeSearch/Moderation \u2705 \u2705 \u2705 \u2705","title":"Feature Support Matrix"},{"location":"DETECTION/#api-reference","text":"","title":"API Reference"},{"location":"DETECTION/#core-types","text":"","title":"Core Types"},{"location":"DETECTION/#detectionresult","text":"type DetectionResult struct { Provider string // Provider used (ollama, gemini, aws, openai) Labels [] Label // Detected objects/labels Description string // Natural language description Text [] TextBlock // Extracted text Faces [] Face // Detected faces Web * WebDetection // Web entities (Gemini) BoundingBoxes [] BoundingBox // Object locations Properties map [ string ] string // Image properties (AWS) Confidence float32 // Overall confidence (0.0-1.0) ProcessedAt time . Time // Processing timestamp RawResponse string // Raw API response (if requested) }","title":"DetectionResult"},{"location":"DETECTION/#label","text":"type Label struct { Name string // Label name (e.g., \"Dog\", \"Car\") Confidence float32 // Confidence score (0.0-1.0) Categories [] string // Parent categories }","title":"Label"},{"location":"DETECTION/#textblock","text":"type TextBlock struct { Text string // Extracted text Confidence float32 // Confidence score (0.0-1.0) BoundingBox * BoundingBox // Text location Language string // Detected language (if available) }","title":"TextBlock"},{"location":"DETECTION/#face","text":"type Face struct { Confidence float32 // Confidence score (0.0-1.0) BoundingBox * BoundingBox // Face location Landmarks [] FaceLandmark // Facial landmarks (eyes, nose, etc.) Emotions map [ string ] float32 // Emotion scores AgeRange string // Estimated age range Gender string // Detected gender }","title":"Face"},{"location":"DETECTION/#detection-options","text":"type DetectOptions struct { Features [] Feature // Features to detect MaxResults int // Maximum labels to return (default: 10) MinConfidence float32 // Minimum confidence threshold (0.0-1.0, default: 0.5) CustomPrompt string // Custom prompt (Gemini/OpenAI) IncludeRawResponse bool // Include raw API response } // Create default options opts := detection . DefaultDetectOptions () // Customize options opts := & detection . DetectOptions { Features : [] detection . Feature { detection . FeatureLabels , detection . FeatureText }, MaxResults : 20 , MinConfidence : 0.7 , }","title":"Detection Options"},{"location":"DETECTION/#methods","text":"","title":"Methods"},{"location":"DETECTION/#imagedetect","text":"func ( img * Image ) Detect ( ctx context . Context , provider string , opts ...* detection . DetectOptions ) ( * detection . DetectionResult , error ) High-level method on *imgx.Image instances. Parameters: - ctx : Context for cancellation and timeouts - provider : Provider name (\"ollama\", \"gemma3\", \"qwen3-vl\", \"gemini\", \"google\", \"aws\", \"rekognition\", \"openai\") - opts : Optional detection options Returns: - *DetectionResult : Detection results - error : Error if detection fails","title":"Image.Detect()"},{"location":"DETECTION/#provider-interface","text":"type Provider interface { Detect ( ctx context . Context , img * image . NRGBA , opts * DetectOptions ) ( * DetectionResult , error ) Name () string IsConfigured () bool } Direct provider access for advanced use cases: provider , err := detection . GetProvider ( \"ollama\" ) if err != nil { log . Fatal ( err ) } result , err := provider . Detect ( ctx , img . ToNRGBA (), opts )","title":"Provider Interface"},{"location":"DETECTION/#examples","text":"","title":"Examples"},{"location":"DETECTION/#basic-detection","text":"img , _ := imgx . Load ( \"photo.jpg\" ) ctx := context . Background () result , err := img . Detect ( ctx , \"ollama\" ) if err != nil { log . Fatal ( err ) } for _ , label := range result . Labels { fmt . Printf ( \"%s: %.1f%%\\n\" , label . Name , label . Confidence * 100 ) }","title":"Basic Detection"},{"location":"DETECTION/#multiple-features","text":"opts := & detection . DetectOptions { Features : [] detection . Feature { detection . FeatureLabels , detection . FeatureText , detection . FeatureFaces , }, MaxResults : 15 , MinConfidence : 0.7 , } result , err := img . Detect ( ctx , \"aws\" , opts ) if err != nil { log . Fatal ( err ) } // Labels fmt . Println ( \"Objects:\" , len ( result . Labels )) // Text extraction fmt . Println ( \"Text found:\" ) for _ , text := range result . Text { fmt . Printf ( \"- %s\\n\" , text . Text ) } // Faces fmt . Printf ( \"Found %d faces\\n\" , len ( result . Faces ))","title":"Multiple Features"},{"location":"DETECTION/#aws-image-properties","text":"// Get image quality metrics and dominant colors opts := & detection . DetectOptions { Features : [] detection . Feature { detection . FeatureProperties }, } result , err := img . Detect ( ctx , \"aws\" , opts ) if err != nil { log . Fatal ( err ) } // Access properties fmt . Println ( \"Brightness:\" , result . Properties [ \"brightness\" ]) fmt . Println ( \"Sharpness:\" , result . Properties [ \"sharpness\" ]) fmt . Println ( \"Contrast:\" , result . Properties [ \"contrast\" ]) fmt . Println ( \"Dominant colors:\" , result . Properties [ \"dominant_colors\" ]) fmt . Println ( \"Color 1 (hex):\" , result . Properties [ \"color_1_hex\" ]) fmt . Println ( \"Color 1 (rgb):\" , result . Properties [ \"color_1_rgb\" ])","title":"AWS Image Properties"},{"location":"DETECTION/#custom-prompt-geminiopenai","text":"opts := & detection . DetectOptions { CustomPrompt : \"Is there a dog in this image? What breed might it be?\" , } result , err := img . Detect ( ctx , \"gemini\" , opts ) if err != nil { log . Fatal ( err ) } fmt . Println ( \"Description:\" , result . Description )","title":"Custom Prompt (Gemini/OpenAI)"},{"location":"DETECTION/#compare-multiple-providers","text":"providers := [] string { \"gemini\" , \"aws\" , \"openai\" } for _ , provider := range providers { result , err := img . Detect ( ctx , provider ) if err != nil { fmt . Printf ( \"%s error: %v\\n\" , provider , err ) continue } fmt . Printf ( \"\\n%s results:\\n\" , strings . ToUpper ( provider )) for _ , label := range result . Labels [: 5 ] { fmt . Printf ( \" - %s (%.1f%%)\\n\" , label . Name , label . Confidence * 100 ) } }","title":"Compare Multiple Providers"},{"location":"DETECTION/#error-handling","text":"result , err := img . Detect ( ctx , \"aws\" ) if err != nil { // Check for specific error types if errors . Is ( err , detection . ErrProviderNotConfigured ) { log . Fatal ( \"AWS credentials not configured. Run: aws configure\" ) } // Check error message for details if strings . Contains ( err . Error (), \"invalid credentials\" ) { log . Fatal ( \"AWS credentials are invalid or expired\" ) } log . Fatal ( err ) }","title":"Error Handling"},{"location":"DETECTION/#with-context-timeout","text":"// Set 10 second timeout ctx , cancel := context . WithTimeout ( context . Background (), 10 * time . Second ) defer cancel () result , err := img . Detect ( ctx , \"gemini\" ) if err != nil { if errors . Is ( err , context . DeadlineExceeded ) { log . Fatal ( \"Detection timed out\" ) } log . Fatal ( err ) }","title":"With Context Timeout"},{"location":"DETECTION/#batch-processing","text":"images := [] string { \"photo1.jpg\" , \"photo2.jpg\" , \"photo3.jpg\" } ctx := context . Background () for _ , imagePath := range images { img , err := imgx . Load ( imagePath ) if err != nil { log . Printf ( \"Failed to load %s: %v\" , imagePath , err ) continue } result , err := img . Detect ( ctx , \"gemini\" ) if err != nil { log . Printf ( \"Failed to detect %s: %v\" , imagePath , err ) continue } fmt . Printf ( \"\\n%s:\\n\" , imagePath ) for i , label := range result . Labels { if i >= 3 { break } // Top 3 labels fmt . Printf ( \" %s (%.1f%%)\\n\" , label . Name , label . Confidence * 100 ) } }","title":"Batch Processing"},{"location":"DETECTION/#best-practices","text":"","title":"Best Practices"},{"location":"DETECTION/#1-choose-the-right-provider","text":"Gemini : Best for general-purpose detection, custom prompts, and web entity detection AWS Rekognition : Best for production workloads, image properties, and when you need reliable face detection OpenAI Vision : Best for natural language descriptions and when you need GPT-4o's reasoning","title":"1. Choose the Right Provider"},{"location":"DETECTION/#2-set-appropriate-confidence-thresholds","text":"// For critical applications, use higher confidence opts := & detection . DetectOptions { MinConfidence : 0.8 , // Only high-confidence results } // For exploratory analysis, use lower confidence opts := & detection . DetectOptions { MinConfidence : 0.3 , // Catch more possibilities }","title":"2. Set Appropriate Confidence Thresholds"},{"location":"DETECTION/#3-handle-rate-limits","text":"import \"time\" for _ , img := range images { result , err := img . Detect ( ctx , \"gemini\" ) if err != nil { if strings . Contains ( err . Error (), \"rate limit\" ) { time . Sleep ( 2 * time . Second ) result , err = img . Detect ( ctx , \"gemini\" ) // Retry } if err != nil { log . Printf ( \"Error: %v\" , err ) continue } } // Process result... }","title":"3. Handle Rate Limits"},{"location":"DETECTION/#4-use-context-for-cancellation","text":"ctx , cancel := context . WithCancel ( context . Background ()) // Cancel on Ctrl+C go func () { sigChan := make ( chan os . Signal , 1 ) signal . Notify ( sigChan , os . Interrupt ) <- sigChan cancel () }() result , err := img . Detect ( ctx , \"gemini\" )","title":"4. Use Context for Cancellation"},{"location":"DETECTION/#5-cache-results","text":"type DetectionCache struct { mu sync . RWMutex cache map [ string ] * detection . DetectionResult } func ( c * DetectionCache ) Get ( key string ) ( * detection . DetectionResult , bool ) { c . mu . RLock () defer c . mu . RUnlock () result , ok := c . cache [ key ] return result , ok } func ( c * DetectionCache ) Set ( key string , result * detection . DetectionResult ) { c . mu . Lock () defer c . mu . Unlock () c . cache [ key ] = result }","title":"5. Cache Results"},{"location":"DETECTION/#pricing-considerations","text":"","title":"Pricing Considerations"},{"location":"DETECTION/#aws-rekognition_1","text":"Important : The properties feature has separate pricing. Labels only : --features labels \u2192 Standard DetectLabels pricing Properties only : --features properties \u2192 Image Properties pricing only Both : --features labels,properties \u2192 Charged for BOTH APIs Example costs (as of 2024): - DetectLabels: ~$0.001 per image (first 1M images/month) - Image Properties: Additional charge when combined with labels - DetectText, DetectFaces: Separate pricing Recommendation : Only request properties when needed to minimize costs.","title":"AWS Rekognition"},{"location":"DETECTION/#gemini","text":"Free tier available with rate limits Pay-as-you-go pricing after free tier Custom prompts may use more tokens","title":"Gemini"},{"location":"DETECTION/#openai-vision_1","text":"Charged per API call GPT-4o has different pricing than GPT-4 Image size affects cost","title":"OpenAI Vision"},{"location":"DETECTION/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"DETECTION/#common-issues","text":"","title":"Common Issues"},{"location":"DETECTION/#1-provider-not-configured","text":"Gemini: # Check if key is set echo $GEMINI_API_KEY # Set the key export GEMINI_API_KEY = \"your-key\" AWS: # Test credentials aws sts get-caller-identity # If that fails, run aws configure OpenAI: # Check if key is set echo $OPENAI_API_KEY # Set the key export OPENAI_API_KEY = \"sk-...\"","title":"1. \"Provider not configured\""},{"location":"DETECTION/#2-invalid-aws-credentials","text":"This error means your AWS credentials are incorrect or expired. # Verify credentials are correct aws sts get-caller-identity # If using temporary credentials, they may have expired # Get new credentials from your IAM administrator # Check which credential source is being used AWS_PROFILE = default aws sts get-caller-identity","title":"2. \"Invalid AWS credentials\""},{"location":"DETECTION/#3-access-denied-aws","text":"Your IAM user/role lacks necessary permissions. Required IAM permissions: { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : [ \"rekognition:DetectLabels\" , \"rekognition:DetectText\" , \"rekognition:DetectFaces\" , \"rekognition:DetectModerationLabels\" ], \"Resource\" : \"*\" } ] }","title":"3. \"Access denied\" (AWS)"},{"location":"DETECTION/#4-rate-limiting","text":"If you hit rate limits, implement exponential backoff: func detectWithRetry ( img * imgx . Image , ctx context . Context , provider string ) ( * detection . DetectionResult , error ) { maxRetries := 3 baseDelay := time . Second for i := 0 ; i < maxRetries ; i ++ { result , err := img . Detect ( ctx , provider ) if err == nil { return result , nil } if ! strings . Contains ( err . Error (), \"rate limit\" ) { return nil , err } if i < maxRetries - 1 { delay := baseDelay * time . Duration ( 1 << uint ( i )) time . Sleep ( delay ) } } return nil , fmt . Errorf ( \"max retries exceeded\" ) }","title":"4. Rate Limiting"},{"location":"DETECTION/#5-large-images","text":"If you get errors about image size: // Resize large images before detection if img . Bounds (). Dx () > 2048 || img . Bounds (). Dy () > 2048 { img = img . Fit ( 2048 , 2048 , imgx . Lanczos ) } result , err := img . Detect ( ctx , \"gemini\" )","title":"5. Large Images"},{"location":"DETECTION/#additional-resources","text":"Google Gemini API Documentation AWS Rekognition Documentation OpenAI Vision API Documentation imgx GitHub Repository Example Code","title":"Additional Resources"},{"location":"DETECTION/#see-also","text":"CLI Documentation - Command-line usage Main README - Library overview Versioning - Version management","title":"See Also"},{"location":"RELEASING/","text":"Releasing imgx \u00b6 Quick guide for maintainers on how to release new versions. Quick Release \u00b6 # 1. Make sure main branch is up to date git checkout main git pull # 2. Run tests go test ./... # 3. Create and push a tag (GitHub Actions does the rest!) git tag -a v1.1.0 -m \"Release v1.1.0\" git push origin v1.1.0 That's it! GitHub Actions will automatically: - \u2705 Update version in code files - \u2705 Commit changes back to main - \u2705 Build binaries for all platforms - \u2705 Create GitHub release What Happens Automatically \u00b6 When you push a tag like v1.1.0 , the release workflow: Extracts Version Tag: v1.1.0 \u2192 Version: 1.1.0 Updates Files version.go : const Version = \"1.1.0\" VERSION : 1.1.0 Commits Back to Main chore: bump version to v1.1.0 [skip ci] Builds Binaries Linux: amd64, arm64 macOS: amd64, arm64 Windows: amd64 Creates Release GitHub release with all binaries Checksums and SBOMs Release notes Pre-Release Checklist \u00b6 Before creating a release tag: [ ] All tests pass: go test ./... [ ] CLI builds: go build ./cmd/imgx [ ] CLI works: ./imgx --version [ ] Examples work: go run examples/author/main.go [ ] Documentation is updated [ ] CHANGELOG is updated (if you maintain one) [ ] No uncommitted changes: git status Version Numbers \u00b6 Follow Semantic Versioning : v1.0.0 \u2192 v2.0.0 - Breaking changes Example: Removed Options field, changed function signature v1.0.0 \u2192 v1.1.0 - New features Example: Added new image filter, new CLI command v1.0.0 \u2192 v1.0.1 - Bug fixes Example: Fixed memory leak, corrected calculation Release Types \u00b6 Stable Release \u00b6 git tag -a v1.1.0 -m \"Release v1.1.0\" git push origin v1.1.0 Pre-Release (Beta, RC) \u00b6 git tag -a v1.1.0-beta.1 -m \"Beta release v1.1.0-beta.1\" git push origin v1.1.0-beta.1 Mark as pre-release on GitHub after creation. Manual Release (Emergency) \u00b6 If GitHub Actions fails, you can release manually: 1. Update Version \u00b6 ./update-version.sh 1 .1.0 git commit -am \"chore: bump version to v1.1.0\" git push 2. Build Locally \u00b6 # Install goreleaser go install github.com/goreleaser/goreleaser@latest # Create snapshot (no tag needed) goreleaser release --snapshot --clean # Or full release (requires tag) git tag -a v1.1.0 -m \"Release v1.1.0\" goreleaser release --clean 3. Upload to GitHub \u00b6 Manually upload binaries from dist/ to GitHub release. Viewing Releases \u00b6 # List all tags git tag -l # Show latest tag git describe --tags --abbrev = 0 # View release on GitHub gh release view v1.1.0 # List all releases gh release list Hotfix Release \u00b6 For urgent bug fixes: # 1. Create hotfix branch git checkout -b hotfix/1.0.1 v1.0.0 # 2. Fix the bug git commit -am \"fix: critical bug\" # 3. Tag and push git tag -a v1.0.1 -m \"Hotfix v1.0.1\" git push origin v1.0.1 # 4. Merge back git checkout main git merge hotfix/1.0.1 git push Rollback \u00b6 If you need to roll back a release: # 1. Delete tag locally git tag -d v1.1.0 # 2. Delete tag on remote git push origin :refs/tags/v1.1.0 # 3. Delete GitHub release gh release delete v1.1.0 # 4. Revert version commit git revert <commit-hash> git push Testing Before Release \u00b6 # Run all tests go test ./... # Test with race detector go test -race ./... # Build for all platforms GOOS = linux GOARCH = amd64 go build ./cmd/imgx GOOS = darwin GOARCH = arm64 go build ./cmd/imgx GOOS = windows GOARCH = amd64 go build ./cmd/imgx # Or use goreleaser snapshot goreleaser release --snapshot --clean Monitoring Release \u00b6 After pushing a tag: # Watch workflow progress gh run watch # View workflow logs gh run list --workflow = release.yml gh run view <run-id> --log # Check release gh release view v1.1.0 Troubleshooting \u00b6 Workflow fails to commit \u00b6 Problem: Permission denied when pushing version commit. Solution: Check that GITHUB_TOKEN has contents: write permission in workflow file. Version not updated \u00b6 Problem: version.go still shows old version after release. Solution: git pull # Pull the automated commit Build fails \u00b6 Problem: GoReleaser build fails. Solution: Check .goreleaser.yml configuration and workflow logs. Tag already exists \u00b6 Problem: Tag v1.1.0 already exists. Solution: # Delete and recreate git tag -d v1.1.0 git push origin :refs/tags/v1.1.0 git tag -a v1.1.0 -m \"Release v1.1.0\" git push origin v1.1.0 Tips \u00b6 \ud83c\udff7\ufe0f Always use annotated tags ( -a ), not lightweight tags \ud83d\udcdd Write clear commit messages \u2705 Test thoroughly before tagging \ud83d\udd04 Pull after workflow completes to get version commit \ud83d\udcca Monitor GitHub Actions for any failures \ud83d\ude80 Announce releases in relevant channels See Also \u00b6 VERSIONING.md - Version management details .github/workflows/release.yml - Release workflow .goreleaser.yml - Build configuration","title":"Release Process"},{"location":"RELEASING/#releasing-imgx","text":"Quick guide for maintainers on how to release new versions.","title":"Releasing imgx"},{"location":"RELEASING/#quick-release","text":"# 1. Make sure main branch is up to date git checkout main git pull # 2. Run tests go test ./... # 3. Create and push a tag (GitHub Actions does the rest!) git tag -a v1.1.0 -m \"Release v1.1.0\" git push origin v1.1.0 That's it! GitHub Actions will automatically: - \u2705 Update version in code files - \u2705 Commit changes back to main - \u2705 Build binaries for all platforms - \u2705 Create GitHub release","title":"Quick Release"},{"location":"RELEASING/#what-happens-automatically","text":"When you push a tag like v1.1.0 , the release workflow: Extracts Version Tag: v1.1.0 \u2192 Version: 1.1.0 Updates Files version.go : const Version = \"1.1.0\" VERSION : 1.1.0 Commits Back to Main chore: bump version to v1.1.0 [skip ci] Builds Binaries Linux: amd64, arm64 macOS: amd64, arm64 Windows: amd64 Creates Release GitHub release with all binaries Checksums and SBOMs Release notes","title":"What Happens Automatically"},{"location":"RELEASING/#pre-release-checklist","text":"Before creating a release tag: [ ] All tests pass: go test ./... [ ] CLI builds: go build ./cmd/imgx [ ] CLI works: ./imgx --version [ ] Examples work: go run examples/author/main.go [ ] Documentation is updated [ ] CHANGELOG is updated (if you maintain one) [ ] No uncommitted changes: git status","title":"Pre-Release Checklist"},{"location":"RELEASING/#version-numbers","text":"Follow Semantic Versioning : v1.0.0 \u2192 v2.0.0 - Breaking changes Example: Removed Options field, changed function signature v1.0.0 \u2192 v1.1.0 - New features Example: Added new image filter, new CLI command v1.0.0 \u2192 v1.0.1 - Bug fixes Example: Fixed memory leak, corrected calculation","title":"Version Numbers"},{"location":"RELEASING/#release-types","text":"","title":"Release Types"},{"location":"RELEASING/#stable-release","text":"git tag -a v1.1.0 -m \"Release v1.1.0\" git push origin v1.1.0","title":"Stable Release"},{"location":"RELEASING/#pre-release-beta-rc","text":"git tag -a v1.1.0-beta.1 -m \"Beta release v1.1.0-beta.1\" git push origin v1.1.0-beta.1 Mark as pre-release on GitHub after creation.","title":"Pre-Release (Beta, RC)"},{"location":"RELEASING/#manual-release-emergency","text":"If GitHub Actions fails, you can release manually:","title":"Manual Release (Emergency)"},{"location":"RELEASING/#1-update-version","text":"./update-version.sh 1 .1.0 git commit -am \"chore: bump version to v1.1.0\" git push","title":"1. Update Version"},{"location":"RELEASING/#2-build-locally","text":"# Install goreleaser go install github.com/goreleaser/goreleaser@latest # Create snapshot (no tag needed) goreleaser release --snapshot --clean # Or full release (requires tag) git tag -a v1.1.0 -m \"Release v1.1.0\" goreleaser release --clean","title":"2. Build Locally"},{"location":"RELEASING/#3-upload-to-github","text":"Manually upload binaries from dist/ to GitHub release.","title":"3. Upload to GitHub"},{"location":"RELEASING/#viewing-releases","text":"# List all tags git tag -l # Show latest tag git describe --tags --abbrev = 0 # View release on GitHub gh release view v1.1.0 # List all releases gh release list","title":"Viewing Releases"},{"location":"RELEASING/#hotfix-release","text":"For urgent bug fixes: # 1. Create hotfix branch git checkout -b hotfix/1.0.1 v1.0.0 # 2. Fix the bug git commit -am \"fix: critical bug\" # 3. Tag and push git tag -a v1.0.1 -m \"Hotfix v1.0.1\" git push origin v1.0.1 # 4. Merge back git checkout main git merge hotfix/1.0.1 git push","title":"Hotfix Release"},{"location":"RELEASING/#rollback","text":"If you need to roll back a release: # 1. Delete tag locally git tag -d v1.1.0 # 2. Delete tag on remote git push origin :refs/tags/v1.1.0 # 3. Delete GitHub release gh release delete v1.1.0 # 4. Revert version commit git revert <commit-hash> git push","title":"Rollback"},{"location":"RELEASING/#testing-before-release","text":"# Run all tests go test ./... # Test with race detector go test -race ./... # Build for all platforms GOOS = linux GOARCH = amd64 go build ./cmd/imgx GOOS = darwin GOARCH = arm64 go build ./cmd/imgx GOOS = windows GOARCH = amd64 go build ./cmd/imgx # Or use goreleaser snapshot goreleaser release --snapshot --clean","title":"Testing Before Release"},{"location":"RELEASING/#monitoring-release","text":"After pushing a tag: # Watch workflow progress gh run watch # View workflow logs gh run list --workflow = release.yml gh run view <run-id> --log # Check release gh release view v1.1.0","title":"Monitoring Release"},{"location":"RELEASING/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"RELEASING/#workflow-fails-to-commit","text":"Problem: Permission denied when pushing version commit. Solution: Check that GITHUB_TOKEN has contents: write permission in workflow file.","title":"Workflow fails to commit"},{"location":"RELEASING/#version-not-updated","text":"Problem: version.go still shows old version after release. Solution: git pull # Pull the automated commit","title":"Version not updated"},{"location":"RELEASING/#build-fails","text":"Problem: GoReleaser build fails. Solution: Check .goreleaser.yml configuration and workflow logs.","title":"Build fails"},{"location":"RELEASING/#tag-already-exists","text":"Problem: Tag v1.1.0 already exists. Solution: # Delete and recreate git tag -d v1.1.0 git push origin :refs/tags/v1.1.0 git tag -a v1.1.0 -m \"Release v1.1.0\" git push origin v1.1.0","title":"Tag already exists"},{"location":"RELEASING/#tips","text":"\ud83c\udff7\ufe0f Always use annotated tags ( -a ), not lightweight tags \ud83d\udcdd Write clear commit messages \u2705 Test thoroughly before tagging \ud83d\udd04 Pull after workflow completes to get version commit \ud83d\udcca Monitor GitHub Actions for any failures \ud83d\ude80 Announce releases in relevant channels","title":"Tips"},{"location":"RELEASING/#see-also","text":"VERSIONING.md - Version management details .github/workflows/release.yml - Release workflow .goreleaser.yml - Build configuration","title":"See Also"},{"location":"VERSIONING/","text":"Version Management \u00b6 imgx uses a single source of truth for version information across the entire project. Version Files \u00b6 Primary Source \u00b6 version.go - The canonical version definition const Version = \"1.0.0\" Secondary References \u00b6 VERSION - Plain text file for scripts/automation CLI ( cmd/imgx/main.go ) - Uses imgx.Version from version.go Metadata ( metadata_write.go ) - Uses imgx.Version for XMP metadata Automated Release Workflow \u00b6 Creating a Release (Automated) \u00b6 The easiest way to release a new version is to push a git tag. GitHub Actions will automatically handle everything: # 1. Commit your changes git add . git commit -m \"feat: add new feature\" git push # 2. Create and push a tag git tag -a v1.1.0 -m \"Release v1.1.0\" git push origin v1.1.0 What happens automatically: 1. GitHub Actions detects the new tag 2. Extracts version from tag (e.g., v1.1.0 \u2192 1.1.0 ) 3. Updates version.go and VERSION files 4. Commits changes back to main branch with message: chore: bump version to v1.1.0 [skip ci] 5. Builds binaries for multiple platforms using GoReleaser 6. Creates GitHub release with binaries attached Manual Version Update (Optional) \u00b6 If you need to update the version manually without creating a release: Using the Script \u00b6 ./update-version.sh 1 .1.0 Manual Steps \u00b6 Edit version.go : const Version = \"1.1.0\" // Update this Update VERSION file: echo \"1.1.0\" > VERSION Commit: git commit -am \"chore: bump version to v1.1.0\" git push Version Information Location \u00b6 The version appears in: Library metadata - Embedded in XMP metadata as creator_tool XMP:CreatorTool = \"imgx v1.0.0\" CLI version flag imgx --version # Output: imgx version 1.0.0 Go module - When imported by other projects import \"github.com/razzkumar/imgx\" fmt . Println ( imgx . Version ) // \"1.0.0\" Semantic Versioning \u00b6 imgx follows Semantic Versioning : MAJOR (1.x.x) - Incompatible API changes MINOR (x.1.x) - New functionality, backwards compatible PATCH (x.x.1) - Bug fixes, backwards compatible Examples \u00b6 1.0.0 \u2192 2.0.0 - Breaking change (removed Options field) 1.0.0 \u2192 1.1.0 - New feature (added new image filter) 1.0.0 \u2192 1.0.1 - Bug fix (fixed resize calculation) Release Checklist \u00b6 When preparing a release: [ ] Update CHANGELOG.md (if applicable) [ ] Run tests: go test ./... [ ] Build CLI: go build ./cmd/imgx [ ] Test CLI: ./imgx --version [ ] Commit all changes [ ] Create and push tag: git tag -a vX.Y.Z -m \"Release vX.Y.Z\" [ ] Push tag: git push origin vX.Y.Z [ ] GitHub Actions will handle the rest! Checking Current Version \u00b6 From Code \u00b6 import \"github.com/razzkumar/imgx\" func main () { fmt . Println ( \"imgx version:\" , imgx . Version ) } From Command Line \u00b6 # CLI version ./imgx --version # Library version go list -m github.com/razzkumar/imgx # Git tags git describe --tags --abbrev = 0 # From file cat VERSION GitHub Actions Workflow \u00b6 The release workflow ( .github/workflows/release.yml ) performs these steps: Extract Version - Gets version from git tag (removes v prefix) Update Files - Updates version.go and VERSION Commit - Commits changes back to main with [skip ci] to avoid loops Build - Uses GoReleaser to build binaries for: Linux (amd64, arm64) macOS (amd64, arm64) Windows (amd64) Release - Creates GitHub release with all binaries Workflow Triggers \u00b6 The workflow triggers on any tag push: on : push : tags : - \"*\" Required Permissions \u00b6 permissions : contents : write # To create releases and commit packages : write # To publish packages Troubleshooting \u00b6 Version not updated after tag push \u00b6 Check GitHub Actions workflow run: # View workflow status gh run list --workflow = release.yml # View specific run gh run view <run-id> --log Manual fix if workflow fails \u00b6 # 1. Pull latest changes git pull # 2. Update version manually ./update-version.sh 1 .1.0 # 3. Push changes git push Notes \u00b6 Always use semantic versioning (MAJOR.MINOR.PATCH) Tag format: v1.0.0 (with v prefix) Stored version: 1.0.0 (without v prefix) The [skip ci] in commit message prevents infinite workflow loops version.go is the source of truth for Go code VERSION file is for scripts and automation CLI automatically uses library version All processed images show the version in metadata","title":"Version Management"},{"location":"VERSIONING/#version-management","text":"imgx uses a single source of truth for version information across the entire project.","title":"Version Management"},{"location":"VERSIONING/#version-files","text":"","title":"Version Files"},{"location":"VERSIONING/#primary-source","text":"version.go - The canonical version definition const Version = \"1.0.0\"","title":"Primary Source"},{"location":"VERSIONING/#secondary-references","text":"VERSION - Plain text file for scripts/automation CLI ( cmd/imgx/main.go ) - Uses imgx.Version from version.go Metadata ( metadata_write.go ) - Uses imgx.Version for XMP metadata","title":"Secondary References"},{"location":"VERSIONING/#automated-release-workflow","text":"","title":"Automated Release Workflow"},{"location":"VERSIONING/#creating-a-release-automated","text":"The easiest way to release a new version is to push a git tag. GitHub Actions will automatically handle everything: # 1. Commit your changes git add . git commit -m \"feat: add new feature\" git push # 2. Create and push a tag git tag -a v1.1.0 -m \"Release v1.1.0\" git push origin v1.1.0 What happens automatically: 1. GitHub Actions detects the new tag 2. Extracts version from tag (e.g., v1.1.0 \u2192 1.1.0 ) 3. Updates version.go and VERSION files 4. Commits changes back to main branch with message: chore: bump version to v1.1.0 [skip ci] 5. Builds binaries for multiple platforms using GoReleaser 6. Creates GitHub release with binaries attached","title":"Creating a Release (Automated)"},{"location":"VERSIONING/#manual-version-update-optional","text":"If you need to update the version manually without creating a release:","title":"Manual Version Update (Optional)"},{"location":"VERSIONING/#using-the-script","text":"./update-version.sh 1 .1.0","title":"Using the Script"},{"location":"VERSIONING/#manual-steps","text":"Edit version.go : const Version = \"1.1.0\" // Update this Update VERSION file: echo \"1.1.0\" > VERSION Commit: git commit -am \"chore: bump version to v1.1.0\" git push","title":"Manual Steps"},{"location":"VERSIONING/#version-information-location","text":"The version appears in: Library metadata - Embedded in XMP metadata as creator_tool XMP:CreatorTool = \"imgx v1.0.0\" CLI version flag imgx --version # Output: imgx version 1.0.0 Go module - When imported by other projects import \"github.com/razzkumar/imgx\" fmt . Println ( imgx . Version ) // \"1.0.0\"","title":"Version Information Location"},{"location":"VERSIONING/#semantic-versioning","text":"imgx follows Semantic Versioning : MAJOR (1.x.x) - Incompatible API changes MINOR (x.1.x) - New functionality, backwards compatible PATCH (x.x.1) - Bug fixes, backwards compatible","title":"Semantic Versioning"},{"location":"VERSIONING/#examples","text":"1.0.0 \u2192 2.0.0 - Breaking change (removed Options field) 1.0.0 \u2192 1.1.0 - New feature (added new image filter) 1.0.0 \u2192 1.0.1 - Bug fix (fixed resize calculation)","title":"Examples"},{"location":"VERSIONING/#release-checklist","text":"When preparing a release: [ ] Update CHANGELOG.md (if applicable) [ ] Run tests: go test ./... [ ] Build CLI: go build ./cmd/imgx [ ] Test CLI: ./imgx --version [ ] Commit all changes [ ] Create and push tag: git tag -a vX.Y.Z -m \"Release vX.Y.Z\" [ ] Push tag: git push origin vX.Y.Z [ ] GitHub Actions will handle the rest!","title":"Release Checklist"},{"location":"VERSIONING/#checking-current-version","text":"","title":"Checking Current Version"},{"location":"VERSIONING/#from-code","text":"import \"github.com/razzkumar/imgx\" func main () { fmt . Println ( \"imgx version:\" , imgx . Version ) }","title":"From Code"},{"location":"VERSIONING/#from-command-line","text":"# CLI version ./imgx --version # Library version go list -m github.com/razzkumar/imgx # Git tags git describe --tags --abbrev = 0 # From file cat VERSION","title":"From Command Line"},{"location":"VERSIONING/#github-actions-workflow","text":"The release workflow ( .github/workflows/release.yml ) performs these steps: Extract Version - Gets version from git tag (removes v prefix) Update Files - Updates version.go and VERSION Commit - Commits changes back to main with [skip ci] to avoid loops Build - Uses GoReleaser to build binaries for: Linux (amd64, arm64) macOS (amd64, arm64) Windows (amd64) Release - Creates GitHub release with all binaries","title":"GitHub Actions Workflow"},{"location":"VERSIONING/#workflow-triggers","text":"The workflow triggers on any tag push: on : push : tags : - \"*\"","title":"Workflow Triggers"},{"location":"VERSIONING/#required-permissions","text":"permissions : contents : write # To create releases and commit packages : write # To publish packages","title":"Required Permissions"},{"location":"VERSIONING/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"VERSIONING/#version-not-updated-after-tag-push","text":"Check GitHub Actions workflow run: # View workflow status gh run list --workflow = release.yml # View specific run gh run view <run-id> --log","title":"Version not updated after tag push"},{"location":"VERSIONING/#manual-fix-if-workflow-fails","text":"# 1. Pull latest changes git pull # 2. Update version manually ./update-version.sh 1 .1.0 # 3. Push changes git push","title":"Manual fix if workflow fails"},{"location":"VERSIONING/#notes","text":"Always use semantic versioning (MAJOR.MINOR.PATCH) Tag format: v1.0.0 (with v prefix) Stored version: 1.0.0 (without v prefix) The [skip ci] in commit message prevents infinite workflow loops version.go is the source of truth for Go code VERSION file is for scripts and automation CLI automatically uses library version All processed images show the version in metadata","title":"Notes"}]}